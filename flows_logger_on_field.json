[
    {
        "id": "3550c7871873a292",
        "type": "tab",
        "label": "Modbus server",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "88c0a23c3a224791",
        "type": "tab",
        "label": "test decryptage",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "bb145069bb135c47",
        "type": "tab",
        "label": "Get data from gateway",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "df3290af4eccd44c",
        "type": "group",
        "z": "88c0a23c3a224791",
        "name": "Pipeline to decode and store Gateway value V2.0",
        "style": {
            "label": true,
            "fill": "#e3f3d3"
        },
        "nodes": [
            "a229b509d8298ee1",
            "a6e1d5dc445e0c7d",
            "9e9fdffdcf93cb78",
            "642c9077cfcdc2fa",
            "ef8c72ed2afadb50",
            "3abb7945e920ee57",
            "bf764e78fe005200",
            "d7d0309cf06221d3",
            "491826d4ea340a46"
        ],
        "x": 74,
        "y": 59,
        "w": 872,
        "h": 182
    },
    {
        "id": "65277b58fcc9b401",
        "type": "group",
        "z": "88c0a23c3a224791",
        "name": "Fifo to send data to the Server",
        "style": {
            "label": true,
            "fill": "#e3f3d3"
        },
        "nodes": [
            "1f6a7b77a5a149f9",
            "1973604a.b7afd",
            "b1ccc47612487ab2",
            "257677f7.022318",
            "e4922ed8.1e2e5",
            "519acb1d.96e444",
            "7475d947.971d78",
            "2fe2b6b4d2dcd851",
            "16ae32af6b121e2b",
            "2080b13d92474239"
        ],
        "x": 74,
        "y": 339,
        "w": 1062,
        "h": 162
    },
    {
        "id": "dfc06c552b41984f",
        "type": "group",
        "z": "bb145069bb135c47",
        "name": "get data from gateway",
        "style": {
            "fill": "#e3f3d3",
            "label": true
        },
        "nodes": [
            "59f85f1a37c76b2b",
            "d426500231149c27",
            "9c5852b5e4f85c15",
            "870490657bde3b97",
            "f7cfa05cd25b46d5",
            "80b59f0f61cfd322"
        ],
        "x": 34,
        "y": 19,
        "w": 892,
        "h": 142
    },
    {
        "id": "1e1c575a819c6269",
        "type": "modbus-client",
        "name": "",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "127.0.0.1",
        "tcpPort": "1026",
        "tcpType": "DEFAULT",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": "9600",
        "serialDatabits": "8",
        "serialStopbits": "1",
        "serialParity": "none",
        "serialConnectionDelay": "100",
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "1",
        "commandDelay": "1",
        "clientTimeout": "1000",
        "reconnectOnTimeout": true,
        "reconnectTimeout": "2000",
        "parallelUnitIdsAllowed": true,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "b187e5408a519656",
        "type": "inject",
        "z": "3550c7871873a292",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 430,
        "y": 280,
        "wires": [
            [
                "76ba70db5d44bd90"
            ]
        ]
    },
    {
        "id": "76ba70db5d44bd90",
        "type": "function",
        "z": "3550c7871873a292",
        "name": "Init",
        "func": "var nb_register = 106\nvar date_send = new Array(nb_register)\ndate_send.fill(0x7FFF)\nnode.send({ payload: { value: date_send, 'fc': 16, 'unitid': 1, 'address': 0, 'quantity': nb_register }})\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 280,
        "wires": [
            [
                "05fc83215a9b229f"
            ]
        ]
    },
    {
        "id": "05fc83215a9b229f",
        "type": "modbus-flex-write",
        "z": "3550c7871873a292",
        "name": "",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "server": "1e1c575a819c6269",
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 810,
        "y": 280,
        "wires": [
            [],
            []
        ]
    },
    {
        "id": "acc571b05cb0b170",
        "type": "modbus-server",
        "z": "3550c7871873a292",
        "name": "",
        "logEnabled": true,
        "hostname": "",
        "serverPort": "1026",
        "responseDelay": 100,
        "delayUnit": "ms",
        "coilsBufferSize": "0",
        "holdingBufferSize": "110",
        "inputBufferSize": "0",
        "discreteBufferSize": "0",
        "showErrors": true,
        "x": 600,
        "y": 160,
        "wires": [
            [],
            [],
            [],
            [],
            []
        ]
    },
    {
        "id": "22f56f3d8359e03a",
        "type": "function",
        "z": "88c0a23c3a224791",
        "name": "Lora Watteco de coder no time",
        "func": "\n/*\n * JavaScript implementation of brUncompress.\n * for NodeRed\n */\n\n// {{{ Constants\n\nvar ST_UNDEF = 0;\nvar ST_BL = 1;\nvar ST_U4 = 2;\nvar ST_I4 = 3;\nvar ST_U8 = 4;\nvar ST_I8 = 5;\nvar ST_U16 = 6;\nvar ST_I16 = 7;\nvar ST_U24 = 8;\nvar ST_I24 = 9;\nvar ST_U32 = 10;\nvar ST_I32 = 11;\nvar ST_FL = 12;\n\nvar ST = {};\nST[ST_UNDEF] = 0;\nST[ST_BL] = 1;\nST[ST_U4] = 4;\nST[ST_I4] = 4;\nST[ST_U8] = 8;\nST[ST_I8] = 8;\nST[ST_U16] = 16;\nST[ST_I16] = 16;\nST[ST_U24] = 24;\nST[ST_I24] = 24;\nST[ST_U32] = 32;\nST[ST_I32] = 32;\nST[ST_FL] = 32;\n\nvar BR_HUFF_MAX_INDEX_TABLE = 14;\nvar NUMBER_OF_SERIES = 16;\n\nvar HUFF = [\n    [\n        { sz: 2, lbl: 0x000 },\n        { sz: 2, lbl: 0x001 },\n        { sz: 2, lbl: 0x003 },\n        { sz: 3, lbl: 0x005 },\n        { sz: 4, lbl: 0x009 },\n        { sz: 5, lbl: 0x011 },\n        { sz: 6, lbl: 0x021 },\n        { sz: 7, lbl: 0x041 },\n        { sz: 8, lbl: 0x081 },\n        { sz: 10, lbl: 0x200 },\n        { sz: 11, lbl: 0x402 },\n        { sz: 11, lbl: 0x403 },\n        { sz: 11, lbl: 0x404 },\n        { sz: 11, lbl: 0x405 },\n        { sz: 11, lbl: 0x406 },\n        { sz: 11, lbl: 0x407 }\n    ],\n    [\n        { sz: 7, lbl: 0x06f },\n        { sz: 5, lbl: 0x01a },\n        { sz: 4, lbl: 0x00c },\n        { sz: 3, lbl: 0x003 },\n        { sz: 3, lbl: 0x007 },\n        { sz: 2, lbl: 0x002 },\n        { sz: 2, lbl: 0x000 },\n        { sz: 3, lbl: 0x002 },\n        { sz: 6, lbl: 0x036 },\n        { sz: 9, lbl: 0x1bb },\n        { sz: 9, lbl: 0x1b9 },\n        { sz: 10, lbl: 0x375 },\n        { sz: 10, lbl: 0x374 },\n        { sz: 10, lbl: 0x370 },\n        { sz: 11, lbl: 0x6e3 },\n        { sz: 11, lbl: 0x6e2 }\n    ],\n    [\n        { sz: 4, lbl: 0x009 },\n        { sz: 3, lbl: 0x005 },\n        { sz: 2, lbl: 0x000 },\n        { sz: 2, lbl: 0x001 },\n        { sz: 2, lbl: 0x003 },\n        { sz: 5, lbl: 0x011 },\n        { sz: 6, lbl: 0x021 },\n        { sz: 7, lbl: 0x041 },\n        { sz: 8, lbl: 0x081 },\n        { sz: 10, lbl: 0x200 },\n        { sz: 11, lbl: 0x402 },\n        { sz: 11, lbl: 0x403 },\n        { sz: 11, lbl: 0x404 },\n        { sz: 11, lbl: 0x405 },\n        { sz: 11, lbl: 0x406 },\n        { sz: 11, lbl: 0x407 }\n    ]\n];\n\n// }}}\n\n// {{{ Polyfills\nMath.trunc =\n    Math.trunc ||\n    function (x) {\n        if (isNaN(x)) {\n            return NaN;\n        }\n        if (x > 0) {\n            return Math.floor(x);\n        }\n        return Math.ceil(x);\n    };\n// }}}\n\n/**\n * brUncompress main function\n */\nfunction brUncompress(tagsz, argList, hexString, batch_absolute_timestamp) {\n    var out = initResult();\n    var buffer = createBuffer(parseHexString(hexString));\n    var flag = generateFlag(buffer.getNextSample(ST_U8));\n\n    out.batch_counter = buffer.getNextSample(ST_U8, 3);\n    buffer.getNextSample(ST_U8, 1);\n\n    var temp = prePopulateOutput(out, buffer, argList, flag, tagsz);\n    var last_timestamp = temp.last_timestamp;\n    var index_of_the_first_sample = temp.index_of_the_first_sample;\n\n    if (flag.hasSample) {\n        last_timestamp = uncompressSamplesData(\n            out,\n            buffer,\n            index_of_the_first_sample,\n            argList,\n            last_timestamp,\n            flag,\n            tagsz\n        );\n    }\n\n    out.batch_relative_timestamp = extractTimestampFromBuffer(\n        buffer,\n        last_timestamp\n    );\n    return adaptToExpectedFormat(out, argList, batch_absolute_timestamp);\n}\n\n/////////////// Sub functions ///////////////\n\n/**\n * Init br_uncompress result data structure\n */\nfunction initResult() {\n    var series = [],\n        i = 0;\n    while (i < NUMBER_OF_SERIES) {\n        series.push({\n            codingType: 0,\n            codingTable: 0,\n            resolution: null,\n            uncompressSamples: []\n        });\n        i += 1;\n    }\n    return {\n        batch_counter: 0,\n        batch_relative_timestamp: 0,\n        series: series\n    };\n}\n\n/**\n * Function to create a buffer from a byteArray. Allow to read sample from the\n * byteArray to extract data.\n */\nfunction createBuffer(byteArray) {\n    /**\n     * Retrieve the pattern for HUFF table lookup\n     */\n    function bitsBuf2HuffPattern(byteArray, index, nb_bits) {\n        var sourceBitStart = index;\n        var sz = nb_bits - 1;\n        if (byteArray.length * 8 < sourceBitStart + nb_bits) {\n            throw \"Verify that dest buf is large enough\";\n        }\n        var bittoread = 0;\n        var pattern = 0;\n        while (nb_bits > 0) {\n            if (byteArray[sourceBitStart >> 3] & (1 << (sourceBitStart & 0x07))) {\n                pattern |= 1 << (sz - bittoread);\n            }\n            nb_bits--;\n            bittoread++;\n            sourceBitStart++;\n        }\n        return pattern;\n    }\n\n    return {\n        index: 0,\n        byteArray: byteArray,\n        getNextSample: function (sampleType, nbBitsInput) {\n            var nbBits = nbBitsInput || ST[sampleType];\n            var sourceBitStart = this.index;\n            this.index += nbBits;\n            if (sampleType === ST_FL && nbBits !== 32) {\n                throw \"Mauvais sampletype\";\n            }\n\n            var u32 = 0;\n            var nbytes = Math.trunc((nbBits - 1) / 8) + 1;\n            var nbitsfrombyte = nbBits % 8;\n            if (nbitsfrombyte === 0 && nbytes > 0) {\n                nbitsfrombyte = 8;\n            }\n\n            while (nbytes > 0) {\n                var bittoread = 0;\n                while (nbitsfrombyte > 0) {\n                    var idx = sourceBitStart >> 3;\n                    if (this.byteArray[idx] & (1 << (sourceBitStart & 0x07))) {\n                        u32 |= 1 << ((nbytes - 1) * 8 + bittoread);\n                    }\n                    nbitsfrombyte--;\n                    bittoread++;\n                    sourceBitStart += 1;\n                }\n                nbytes--;\n                nbitsfrombyte = 8;\n            }\n            // Propagate the sign bit if 1\n            if (\n                (sampleType == ST_I4 || sampleType == ST_I8 || sampleType == ST_I16 || sampleType == ST_I24) &&\n                u32 & (1 << (nbBits - 1))\n            ) {\n                for (var i = nbBits; i < 32; i++) {\n                    u32 |= 1 << i;\n                    nbBits++;\n                }\n            }\n\n            return u32;\n        },\n\n        /**\n         * Extract sz and bi from Huff table\n         */\n        getNextBifromHi: function (huff_coding) {\n            for (var i = 2; i < 12; i++) {\n                var lhuff = bitsBuf2HuffPattern(this.byteArray, this.index, i);\n                for (var j = 0; j < HUFF[huff_coding].length; j++) {\n                    if (\n                        HUFF[huff_coding][j].sz == i &&\n                        lhuff == HUFF[huff_coding][j].lbl\n                    ) {\n                        this.index += i;\n                        return j;\n                    }\n                }\n            }\n            throw \"Bi not found in HUFF table\"\n        }\n    }\n}\n\n/**\n * Convert the hex string given as parameter to a ByteArray\n */\nfunction parseHexString(str) {\n    str = str\n        .split(\"\")\n        .filter(function (x) {\n            return !isNaN(parseInt(x, 16))\n        })\n        .join(\"\")\n    var result = []\n    while (str.length >= 2) {\n        result.push(parseInt(str.substring(0, 2), 16))\n        str = str.substring(2, str.length)\n    }\n    return result\n}\n\n/**\n * Generate a flag object from an integer value.\n */\nfunction generateFlag(flagAsInt) {\n    var binbase = flagAsInt.toString(2)\n\n    // leftpad\n    while (binbase.length < 8) {\n        binbase = \"0\" + binbase\n    }\n\n    return {\n        isCommonTimestamp: parseInt(binbase[binbase.length - 2], 2),\n        hasSample: !parseInt(binbase[binbase.length - 3], 2),\n        batch_req: parseInt(binbase[binbase.length - 4], 2),\n        nb_of_type_measure: parseInt(binbase.substring(0, 4), 2)\n    }\n}\n\n/**\n * Prepopulate output with relative timestamp and measure of the first sample\n * for each series.\n */\nfunction prePopulateOutput(out, buffer, argList, flag, tagsz) {\n    var currentTimestamp = 0\n    var index_of_the_first_sample = 0\n    for (var i = 0; i < flag.nb_of_type_measure; i++) {\n        var tag = {\n            size: tagsz,\n            lbl: buffer.getNextSample(ST_U8, tagsz)\n        }\n        var sampleIndex = findIndexFromArgList(argList, tag)\n\n        if (i === 0) {\n            index_of_the_first_sample = sampleIndex\n        }\n\n        currentTimestamp = extractTimestampFromBuffer(buffer, currentTimestamp)\n        out.series[sampleIndex] = computeSeries(\n            buffer,\n            argList[sampleIndex].sampletype,\n            tag.lbl,\n            currentTimestamp\n        )\n        if (flag.hasSample) {\n            out.series[sampleIndex].codingType = buffer.getNextSample(ST_U8, 2)\n            out.series[sampleIndex].codingTable = buffer.getNextSample(ST_U8, 2)\n        }\n    }\n    return {\n        last_timestamp: currentTimestamp,\n        index_of_the_first_sample: index_of_the_first_sample\n    }\n}\n\n/**\n * Initialize next series from buffer\n */\nfunction computeSeries(buffer, sampletype, label, currentTimestamp) {\n    return {\n        uncompressSamples: [\n            {\n                data_relative_timestamp: currentTimestamp,\n                data: {\n                    value: getMeasure(buffer, sampletype),\n                    label: label\n                }\n            }\n        ],\n        codingType: 0,\n        codingTable: 0,\n        resolution: null\n    }\n}\n\n/**\n * Return the index of tag lbl in the argument list\n */\nfunction findIndexFromArgList(argList, tag) {\n    for (var i = 0; i < argList.length; i++) {\n        console.log(argList[i].taglbl)\n        console.log(\"loking for \" + tag.lbl)\n        if (argList[i].taglbl === tag.lbl) {\n            console.log('ok for ' + i)\n            return i\n        }\n    }\n    throw \"Cannot find index in argList\"\n}\n\n/**\n * Extract a new time stamp using Huff table, optionnaly from a baseTimestamp\n */\nfunction extractTimestampFromBuffer(buffer, baseTimestamp) {\n    if (baseTimestamp) {\n        var bi = buffer.getNextBifromHi(1)\n        return computeTimestampFromBi(buffer, baseTimestamp, bi)\n    }\n    return buffer.getNextSample(ST_U32)\n}\n\n/**\n * Compute a new timestamp from a previous one, regarding bi value\n */\nfunction computeTimestampFromBi(buffer, baseTimestamp, bi) {\n    if (bi > BR_HUFF_MAX_INDEX_TABLE) {\n        return buffer.getNextSample(ST_U32)\n    }\n    if (bi > 0) {\n        return computeTimestampFromPositiveBi(buffer, baseTimestamp, bi)\n    }\n    return baseTimestamp\n}\n\n/**\n * Compute a new timestamp from a previous one, regarding posotive bi value\n */\nfunction computeTimestampFromPositiveBi(buffer, baseTimestamp, bi) {\n    return buffer.getNextSample(ST_U32, bi) + baseTimestamp + Math.pow(2, bi) - 1\n}\n\n/**\n * Extract the measure from the buffer, handling float case\n */\n\nfunction getMeasure(buffer, sampletype) {\n    var v = buffer.getNextSample(sampletype)\n    return sampletype === ST_FL ? bytes2Float32(v) : v\n}\n\n/**\n * Convert bytes to a float32 representation.\n */\nfunction bytes2Float32(bytes) {\n    var sign = bytes & 0x80000000 ? -1 : 1,\n        exponent = ((bytes >> 23) & 0xff) - 127,\n        significand = bytes & ~(-1 << 23)\n\n    if (exponent == 128) {\n        return sign * (significand ? Number.NaN : Number.POSITIVE_INFINITY)\n    }\n\n    if (exponent == -127) {\n        if (significand === 0) {\n            return sign * 0.0\n        }\n        exponent = -126\n        significand /= 1 << 22\n    } else {\n        significand = (significand | (1 << 23)) / (1 << 23)\n    }\n\n    return sign * significand * Math.pow(2, exponent)\n}\n\n/**\n * Uncompress samples data presenting common timestamp or separate timestamp\n */\nfunction uncompressSamplesData(\n    out,\n    buffer,\n    index_of_the_first_sample,\n    argList,\n    last_timestamp,\n    flag,\n    tagsz\n) {\n    if (flag.isCommonTimestamp) {\n        return handleCommonTimestamp(\n            out,\n            buffer,\n            index_of_the_first_sample,\n            argList,\n            flag,\n            tagsz\n        )\n    }\n    return handleSeparateTimestamp(\n        out,\n        buffer,\n        argList,\n        last_timestamp,\n        flag,\n        tagsz\n    )\n}\n\n/**\n * Uncompress data in case of common timestamp\n */\nfunction handleCommonTimestamp(\n    out,\n    buffer,\n    index_of_the_first_sample,\n    argList,\n    flag,\n    tagsz\n) {\n    //number of sample\n    var nb_sample_to_parse = buffer.getNextSample(ST_U8, 8)\n    var tag = {}\n\n    var temp = initTimestampCommonTable(\n        out,\n        buffer,\n        nb_sample_to_parse,\n        index_of_the_first_sample\n    )\n    var timestampCommon = temp.timestampCommon\n    var lastTimestamp = temp.lastTimestamp\n\n    for (var j = 0; j < flag.nb_of_type_measure; j++) {\n        var first_null_delta_value = 1\n        tag.lbl = buffer.getNextSample(ST_U8, tagsz)\n        var sampleIndex = findIndexFromArgList(argList, tag)\n        for (var i = 0; i < nb_sample_to_parse; i++) {\n            //Available bit\n            var available = buffer.getNextSample(ST_U8, 1)\n            if (available) {\n                //Delta value\n                var bi = buffer.getNextBifromHi(out.series[sampleIndex].codingTable)\n                var currentMeasure = {\n                    data_relative_timestamp: 0,\n                    data: {}\n                }\n                if (bi <= BR_HUFF_MAX_INDEX_TABLE) {\n                    var precedingValue =\n                        out.series[sampleIndex].uncompressSamples[\n                            out.series[sampleIndex].uncompressSamples.length - 1\n                        ].data.value\n                    if (bi > 0) {\n                        currentMeasure.data.value = completeCurrentMeasure(\n                            buffer,\n                            precedingValue,\n                            out.series[sampleIndex].codingType,\n                            argList[sampleIndex].resol,\n                            bi\n                        )\n                    } else {\n                        // (bi <= 0)\n                        if (first_null_delta_value) {\n                            // First value is yet recorded starting from the header\n                            first_null_delta_value = 0\n                            continue\n                        } else {\n                            currentMeasure.data.value = precedingValue\n                        }\n                    }\n                } else {\n                    // bi > BR_HUFF_MAX_INDEX_TABLE\n                    currentMeasure.data.value = buffer.getNextSample(\n                        argList[sampleIndex].sampletype\n                    )\n                }\n                currentMeasure.data_relative_timestamp = timestampCommon[i]\n                out.series[sampleIndex].uncompressSamples.push(currentMeasure)\n            }\n        }\n    }\n    return lastTimestamp\n}\n\n/**\n * Initialize common timestamp table. Returns the table and last calculated timestamp\n */\nfunction initTimestampCommonTable(\n    out,\n    buffer,\n    nbSampleToParse,\n    firstSampleIndex\n) {\n    var timestampCommon = []\n    var lastTimestamp = 0\n    var timestampCoding = buffer.getNextSample(ST_U8, 2)\n    for (var i = 0; i < nbSampleToParse; i++) {\n        //delta timestamp\n        var bi = buffer.getNextBifromHi(timestampCoding)\n        if (bi <= BR_HUFF_MAX_INDEX_TABLE) {\n            if (i === 0) {\n                timestampCommon.push(\n                    out.series[firstSampleIndex].uncompressSamples[0]\n                        .data_relative_timestamp\n                )\n            } else {\n                if (bi > 0) {\n                    var precedingTimestamp = timestampCommon[i - 1]\n                    timestampCommon.push(\n                        buffer.getNextSample(ST_U32, bi) +\n                        precedingTimestamp +\n                        Math.pow(2, bi) -\n                        1\n                    )\n                } else {\n                    timestampCommon.push(precedingTimestamp)\n                }\n            }\n        } else {\n            timestampCommon.push(buffer.getNextSample(ST_U32))\n        }\n        lastTimestamp = timestampCommon[i]\n    }\n    return {\n        timestampCommon: timestampCommon,\n        lastTimestamp: lastTimestamp\n    }\n}\n\n/**\n * Complete current measure from the preceding one\n */\nfunction completeCurrentMeasure(buffer, precedingValue, codingType, resol, bi) {\n    var currentValue = buffer.getNextSample(ST_U16, bi)\n    if (codingType === 0) {\n        // ADLC\n        return computeAdlcValue(currentValue, resol, precedingValue, bi)\n    }\n    if (codingType === 1) {\n        // Positive\n        return (currentValue + Math.pow(2, bi) - 1) * resol + precedingValue\n    }\n    // Negative\n    return precedingValue - (currentValue + (Math.pow(2, bi) - 1)) * resol\n}\n\n/**\n * Return current value in ADLC case\n */\nfunction computeAdlcValue(currentValue, resol, precedingValue, bi) {\n    if (currentValue >= Math.pow(2, bi - 1)) {\n        return currentValue * resol + precedingValue\n    }\n    return (currentValue + 1 - Math.pow(2, bi)) * resol + precedingValue\n}\n\n/**\n * Uncompress data in case of separate timestamp\n */\nfunction handleSeparateTimestamp(\n    out,\n    buffer,\n    argList,\n    last_timestamp,\n    flag,\n    tagsz\n) {\n    var tag = {}\n    for (var i = 0; i < flag.nb_of_type_measure; i++) {\n        tag.lbl = buffer.getNextSample(ST_U8, tagsz)\n        var sampleIndex = findIndexFromArgList(argList, tag)\n        var compressSampleNb = buffer.getNextSample(ST_U8, 8)\n        if (compressSampleNb) {\n            var timestampCoding = buffer.getNextSample(ST_U8, 2)\n            for (var j = 0; j < compressSampleNb; j++) {\n                var precedingRelativeTimestamp =\n                    out.series[sampleIndex].uncompressSamples[\n                        out.series[sampleIndex].uncompressSamples.length - 1\n                    ].data_relative_timestamp\n                var currentMeasure = {\n                    data_relative_timestamp: 0,\n                    data: {}\n                }\n                var bi = buffer.getNextBifromHi(timestampCoding)\n                currentMeasure.data_relative_timestamp = computeTimestampFromBi(\n                    buffer,\n                    precedingRelativeTimestamp,\n                    bi\n                )\n                if (currentMeasure.data_relative_timestamp > last_timestamp) {\n                    last_timestamp = currentMeasure.data_relative_timestamp\n                }\n                bi = buffer.getNextBifromHi(out.series[sampleIndex].codingTable)\n                if (bi <= BR_HUFF_MAX_INDEX_TABLE) {\n                    var precedingValue =\n                        out.series[sampleIndex].uncompressSamples[\n                            out.series[sampleIndex].uncompressSamples.length - 1\n                        ].data.value\n                    if (bi > 0) {\n                        currentMeasure.data.value = completeCurrentMeasure(\n                            buffer,\n                            precedingValue,\n                            out.series[sampleIndex].codingType,\n                            argList[sampleIndex].resol,\n                            bi\n                        )\n                    } else {\n                        // bi <= 0\n                        currentMeasure.data.value = precedingValue\n                    }\n                } else {\n                    // bi > BR_HUFF_MAX_INDEX_TABLE\n                    currentMeasure.data.value = buffer.getNextSample(\n                        argList[sampleIndex].sampletype\n                    )\n                }\n                out.series[sampleIndex].uncompressSamples.push(currentMeasure)\n            }\n        }\n    }\n    return last_timestamp\n}\n\n/**\n * Translate brUncompress output data to expected structure\n */\nfunction adaptToExpectedFormat(out, argList, batchAbsoluteTimestamp) {\n    var returnedGlobalObject = {\n        batch_counter: out.batch_counter,\n        batch_relative_timestamp: out.batch_relative_timestamp\n    }\n    if (batchAbsoluteTimestamp) {\n        returnedGlobalObject.batch_absolute_timestamp = batchAbsoluteTimestamp\n    }\n    returnedGlobalObject.dataset = out.series.reduce(function (\n        acc,\n        current,\n        index\n    ) {\n        return acc.concat(\n            current.uncompressSamples.map(function (item) {\n                var returned = {\n                    data_relative_timestamp: item.data_relative_timestamp,\n                    data: {\n                        value: argList[index].divide\n                            ? item.data.value / argList[index].divide\n                            : item.data.value,\n                        label: argList[index].taglbl\n                    }\n                }\n                if (argList[index].lblname) {\n                    returned.data.label_name = argList[index].lblname\n                }\n                // if (batchAbsoluteTimestamp) {\n                //     returned.data_absolute_timestamp = computeDataAbsoluteTimestamp(\n                //         batchAbsoluteTimestamp,\n                //         out.batch_relative_timestamp,\n                //         item.data_relative_timestamp\n                //     )\n                // }\n                return returned\n            })\n        )\n    },\n        [])\n    return returnedGlobalObject\n}\n\n/**\n * Compute data absolute timestamp from batch absolute timestamp (bat), batch\n * relative timestamp (brt) and data relative timestamp (drt)\n */\n// function computeDataAbsoluteTimestamp(bat, brt, drt) {\n//   return new Date(new Date(bat) - (brt - drt) * 1000).toISOString()\n// }\n\ntry {\n    module.exports = brUncompress\n} catch (e) {\n    // when called from nashorn,  module.exports is unavailableâ€¦\n}\n\n// vim: fdm=marker\n\n\nvar time = new Date().toLocaleString(); //current time in right time format\n\nvar data = brUncompress(\n    msg.batch_size,  // <<==  the Batch Tag size\n    msg.fields_param,    // From here the batch fileds parameter list\n    msg.payload // This is the batch frame\n)\n    ;\nmsg = { payload: data };\n// console.log(msg)\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 1100,
        "wires": [
            []
        ],
        "info": "## Purpose \r\nThis node decode Lorawan tram received from Watecco sensor\r\n\r\n## Input \r\n```\r\nmsg.payload = \"tram_of_sensor_in_hex\"\r\nmsg.batch_size = int\r\nmsg.fields_param = [the batch fileds parameter list]\r\n```\r\nThis information could be find  [there](https://lora.watteco.fr/Lora/?trameBatch=QgUABpjPAAAAABF7AAAAgJA9AAAAQNgOysMBIgogwI4IsCMC7IgESBKRJCRJGOQD&timestamp=&BatchAttributes=4+0%2C1%2C10%2CIndex1+1%2C1%2C10%2CIndex2+2%2C1%2C10%2CIndex3+3%2C1%2C1%2CState1+4%2C1%2C1%2CState2+5%2C1%2C1%2CState3+6%2C100%2C6%2CBatteryLevel+7%2C1%2C6%2CMultiState&checkbasebatch=checkox_value&+submit=Submit2)\r\n\r\n**Exemple :** \r\n\r\n```\r\nmsg.payload = \"42070005474f00000000117b00000080903d00000040d80e2ac401220a20c08e08b02302ec880448129124244918e400\"\r\nmsg.batch_size = 4\r\nmsg.fields_param = [\r\n    {\r\n      taglbl: 0,\r\n      resol: 1,\r\n      sampletype: 10,\r\n      lblname: \"Index1\"\r\n    },\r\n    {\r\n      taglbl: 1,\r\n      resol: 1,\r\n      sampletype: 10,\r\n      lblname: \"Index2\"\r\n    },\r\n    {\r\n      taglbl: 2,\r\n      resol: 1,\r\n      sampletype: 10,\r\n      lblname: \"Index3\"\r\n    },\r\n    {\r\n      taglbl: 3,\r\n      resol: 1,\r\n      sampletype: 1,\r\n      lblname: \"State1\"\r\n    },\r\n    {\r\n      taglbl: 4,\r\n      resol: 1,\r\n      sampletype: 1,\r\n      lblname: \"State2\"\r\n    },\r\n    {\r\n      taglbl: 5,\r\n      resol: 1,\r\n      sampletype: 1,\r\n      lblname: \"State3\"\r\n    },\r\n    {\r\n      taglbl: 6,\r\n      resol: 100,\r\n      sampletype: 6,\r\n      lblname: \"BatteryLevel\"\r\n    },\r\n    {\r\n      taglbl: 7,\r\n      resol: 1,\r\n      sampletype: 6,\r\n      lblname: \"MultiState\"\r\n    }\r\n  ]\r\n```"
    },
    {
        "id": "9e9fdffdcf93cb78",
        "type": "function",
        "z": "88c0a23c3a224791",
        "g": "df3290af4eccd44c",
        "name": "Watteco decoder",
        "func": "\n/*\n * JavaScript implementation of brUncompress.\n * for NodeRed\n */\n\n// {{{ Constants\n\nvar ST_UNDEF = 0;\nvar ST_BL = 1;\nvar ST_U4 = 2;\nvar ST_I4 = 3;\nvar ST_U8 = 4;\nvar ST_I8 = 5;\nvar ST_U16 = 6;\nvar ST_I16 = 7;\nvar ST_U24 = 8;\nvar ST_I24 = 9;\nvar ST_U32 = 10;\nvar ST_I32 = 11;\nvar ST_FL = 12;\n\nvar ST = {};\nST[ST_UNDEF] = 0;\nST[ST_BL] = 1;\nST[ST_U4] = 4;\nST[ST_I4] = 4;\nST[ST_U8] = 8;\nST[ST_I8] = 8;\nST[ST_U16] = 16;\nST[ST_I16] = 16;\nST[ST_U24] = 24;\nST[ST_I24] = 24;\nST[ST_U32] = 32;\nST[ST_I32] = 32;\nST[ST_FL] = 32;\n\nvar BR_HUFF_MAX_INDEX_TABLE = 14;\nvar NUMBER_OF_SERIES = 16;\n\nvar HUFF = [\n    [\n        { sz: 2, lbl: 0x000 },\n        { sz: 2, lbl: 0x001 },\n        { sz: 2, lbl: 0x003 },\n        { sz: 3, lbl: 0x005 },\n        { sz: 4, lbl: 0x009 },\n        { sz: 5, lbl: 0x011 },\n        { sz: 6, lbl: 0x021 },\n        { sz: 7, lbl: 0x041 },\n        { sz: 8, lbl: 0x081 },\n        { sz: 10, lbl: 0x200 },\n        { sz: 11, lbl: 0x402 },\n        { sz: 11, lbl: 0x403 },\n        { sz: 11, lbl: 0x404 },\n        { sz: 11, lbl: 0x405 },\n        { sz: 11, lbl: 0x406 },\n        { sz: 11, lbl: 0x407 }\n    ],\n    [\n        { sz: 7, lbl: 0x06f },\n        { sz: 5, lbl: 0x01a },\n        { sz: 4, lbl: 0x00c },\n        { sz: 3, lbl: 0x003 },\n        { sz: 3, lbl: 0x007 },\n        { sz: 2, lbl: 0x002 },\n        { sz: 2, lbl: 0x000 },\n        { sz: 3, lbl: 0x002 },\n        { sz: 6, lbl: 0x036 },\n        { sz: 9, lbl: 0x1bb },\n        { sz: 9, lbl: 0x1b9 },\n        { sz: 10, lbl: 0x375 },\n        { sz: 10, lbl: 0x374 },\n        { sz: 10, lbl: 0x370 },\n        { sz: 11, lbl: 0x6e3 },\n        { sz: 11, lbl: 0x6e2 }\n    ],\n    [\n        { sz: 4, lbl: 0x009 },\n        { sz: 3, lbl: 0x005 },\n        { sz: 2, lbl: 0x000 },\n        { sz: 2, lbl: 0x001 },\n        { sz: 2, lbl: 0x003 },\n        { sz: 5, lbl: 0x011 },\n        { sz: 6, lbl: 0x021 },\n        { sz: 7, lbl: 0x041 },\n        { sz: 8, lbl: 0x081 },\n        { sz: 10, lbl: 0x200 },\n        { sz: 11, lbl: 0x402 },\n        { sz: 11, lbl: 0x403 },\n        { sz: 11, lbl: 0x404 },\n        { sz: 11, lbl: 0x405 },\n        { sz: 11, lbl: 0x406 },\n        { sz: 11, lbl: 0x407 }\n    ]\n];\n\n// }}}\n\n// {{{ Polyfills\nMath.trunc =\n    Math.trunc ||\n    function (x) {\n        if (isNaN(x)) {\n            return NaN;\n        }\n        if (x > 0) {\n            return Math.floor(x);\n        }\n        return Math.ceil(x);\n    };\n// }}}\n\n/**\n * brUncompress main function\n */\nfunction brUncompress(tagsz, argList, hexString, batch_absolute_timestamp) {\n    var out = initResult();\n    var buffer = createBuffer(parseHexString(hexString));\n    var flag = generateFlag(buffer.getNextSample(ST_U8));\n\n    out.batch_counter = buffer.getNextSample(ST_U8, 3);\n    buffer.getNextSample(ST_U8, 1);\n\n    var temp = prePopulateOutput(out, buffer, argList, flag, tagsz);\n    var last_timestamp = temp.last_timestamp;\n    var index_of_the_first_sample = temp.index_of_the_first_sample;\n\n    if (flag.hasSample) {\n        last_timestamp = uncompressSamplesData(\n            out,\n            buffer,\n            index_of_the_first_sample,\n            argList,\n            last_timestamp,\n            flag,\n            tagsz\n        );\n    }\n\n    out.batch_relative_timestamp = extractTimestampFromBuffer(\n        buffer,\n        last_timestamp\n    );\n    return adaptToExpectedFormat(out, argList, batch_absolute_timestamp);\n}\n\n/////////////// Sub functions ///////////////\n\n/**\n * Init br_uncompress result data structure\n */\nfunction initResult() {\n    var series = [],\n        i = 0;\n    while (i < NUMBER_OF_SERIES) {\n        series.push({\n            codingType: 0,\n            codingTable: 0,\n            resolution: null,\n            uncompressSamples: []\n        });\n        i += 1;\n    }\n    return {\n        batch_counter: 0,\n        batch_relative_timestamp: 0,\n        series: series\n    };\n}\n\n/**\n * Function to create a buffer from a byteArray. Allow to read sample from the\n * byteArray to extract data.\n */\nfunction createBuffer(byteArray) {\n    /**\n     * Retrieve the pattern for HUFF table lookup\n     */\n    function bitsBuf2HuffPattern(byteArray, index, nb_bits) {\n        var sourceBitStart = index;\n        var sz = nb_bits - 1;\n        if (byteArray.length * 8 < sourceBitStart + nb_bits) {\n            throw \"Verify that dest buf is large enough\";\n        }\n        var bittoread = 0;\n        var pattern = 0;\n        while (nb_bits > 0) {\n            if (byteArray[sourceBitStart >> 3] & (1 << (sourceBitStart & 0x07))) {\n                pattern |= 1 << (sz - bittoread);\n            }\n            nb_bits--;\n            bittoread++;\n            sourceBitStart++;\n        }\n        return pattern;\n    }\n\n    return {\n        index: 0,\n        byteArray: byteArray,\n        getNextSample: function (sampleType, nbBitsInput) {\n            var nbBits = nbBitsInput || ST[sampleType];\n            var sourceBitStart = this.index;\n            this.index += nbBits;\n            if (sampleType === ST_FL && nbBits !== 32) {\n                throw \"Mauvais sampletype\";\n            }\n\n            var u32 = 0;\n            var nbytes = Math.trunc((nbBits - 1) / 8) + 1;\n            var nbitsfrombyte = nbBits % 8;\n            if (nbitsfrombyte === 0 && nbytes > 0) {\n                nbitsfrombyte = 8;\n            }\n\n            while (nbytes > 0) {\n                var bittoread = 0;\n                while (nbitsfrombyte > 0) {\n                    var idx = sourceBitStart >> 3;\n                    if (this.byteArray[idx] & (1 << (sourceBitStart & 0x07))) {\n                        u32 |= 1 << ((nbytes - 1) * 8 + bittoread);\n                    }\n                    nbitsfrombyte--;\n                    bittoread++;\n                    sourceBitStart += 1;\n                }\n                nbytes--;\n                nbitsfrombyte = 8;\n            }\n            // Propagate the sign bit if 1\n            if (\n                (sampleType == ST_I4 || sampleType == ST_I8 || sampleType == ST_I16 || sampleType == ST_I24) &&\n                u32 & (1 << (nbBits - 1))\n            ) {\n                for (var i = nbBits; i < 32; i++) {\n                    u32 |= 1 << i;\n                    nbBits++;\n                }\n            }\n\n            return u32;\n        },\n\n        /**\n         * Extract sz and bi from Huff table\n         */\n        getNextBifromHi: function (huff_coding) {\n            for (var i = 2; i < 12; i++) {\n                var lhuff = bitsBuf2HuffPattern(this.byteArray, this.index, i);\n                for (var j = 0; j < HUFF[huff_coding].length; j++) {\n                    if (\n                        HUFF[huff_coding][j].sz == i &&\n                        lhuff == HUFF[huff_coding][j].lbl\n                    ) {\n                        this.index += i;\n                        return j;\n                    }\n                }\n            }\n            throw \"Bi not found in HUFF table\"\n        }\n    }\n}\n\n/**\n * Convert the hex string given as parameter to a ByteArray\n */\nfunction parseHexString(str) {\n    str = str\n        .split(\"\")\n        .filter(function (x) {\n            return !isNaN(parseInt(x, 16))\n        })\n        .join(\"\")\n    var result = []\n    while (str.length >= 2) {\n        result.push(parseInt(str.substring(0, 2), 16))\n        str = str.substring(2, str.length)\n    }\n    return result\n}\n\n/**\n * Generate a flag object from an integer value.\n */\nfunction generateFlag(flagAsInt) {\n    var binbase = flagAsInt.toString(2)\n\n    // leftpad\n    while (binbase.length < 8) {\n        binbase = \"0\" + binbase\n    }\n\n    return {\n        isCommonTimestamp: parseInt(binbase[binbase.length - 2], 2),\n        hasSample: !parseInt(binbase[binbase.length - 3], 2),\n        batch_req: parseInt(binbase[binbase.length - 4], 2),\n        nb_of_type_measure: parseInt(binbase.substring(0, 4), 2)\n    }\n}\n\n/**\n * Prepopulate output with relative timestamp and measure of the first sample\n * for each series.\n */\nfunction prePopulateOutput(out, buffer, argList, flag, tagsz) {\n    var currentTimestamp = 0\n    var index_of_the_first_sample = 0\n    for (var i = 0; i < flag.nb_of_type_measure; i++) {\n        var tag = {\n            size: tagsz,\n            lbl: buffer.getNextSample(ST_U8, tagsz)\n        }\n        var sampleIndex = findIndexFromArgList(argList, tag)\n\n        if (i === 0) {\n            index_of_the_first_sample = sampleIndex\n        }\n\n        currentTimestamp = extractTimestampFromBuffer(buffer, currentTimestamp)\n        out.series[sampleIndex] = computeSeries(\n            buffer,\n            argList[sampleIndex].sampletype,\n            tag.lbl,\n            currentTimestamp\n        )\n        if (flag.hasSample) {\n            out.series[sampleIndex].codingType = buffer.getNextSample(ST_U8, 2)\n            out.series[sampleIndex].codingTable = buffer.getNextSample(ST_U8, 2)\n        }\n    }\n    return {\n        last_timestamp: currentTimestamp,\n        index_of_the_first_sample: index_of_the_first_sample\n    }\n}\n\n/**\n * Initialize next series from buffer\n */\nfunction computeSeries(buffer, sampletype, label, currentTimestamp) {\n    return {\n        uncompressSamples: [\n            {\n                data_relative_timestamp: currentTimestamp,\n                data: {\n                    value: getMeasure(buffer, sampletype),\n                    label: label\n                }\n            }\n        ],\n        codingType: 0,\n        codingTable: 0,\n        resolution: null\n    }\n}\n\n/**\n * Return the index of tag lbl in the argument list\n */\nfunction findIndexFromArgList(argList, tag) {\n    for (var i = 0; i < argList.length; i++) {\n        if (argList[i].taglbl === tag.lbl) {\n            return i\n        }\n    }\n    throw \"Cannot find index in argList\"\n}\n\n/**\n * Extract a new time stamp using Huff table, optionnaly from a baseTimestamp\n */\nfunction extractTimestampFromBuffer(buffer, baseTimestamp) {\n    if (baseTimestamp) {\n        var bi = buffer.getNextBifromHi(1)\n        return computeTimestampFromBi(buffer, baseTimestamp, bi)\n    }\n    return buffer.getNextSample(ST_U32)\n}\n\n/**\n * Compute a new timestamp from a previous one, regarding bi value\n */\nfunction computeTimestampFromBi(buffer, baseTimestamp, bi) {\n    if (bi > BR_HUFF_MAX_INDEX_TABLE) {\n        return buffer.getNextSample(ST_U32)\n    }\n    if (bi > 0) {\n        return computeTimestampFromPositiveBi(buffer, baseTimestamp, bi)\n    }\n    return baseTimestamp\n}\n\n/**\n * Compute a new timestamp from a previous one, regarding posotive bi value\n */\nfunction computeTimestampFromPositiveBi(buffer, baseTimestamp, bi) {\n    return buffer.getNextSample(ST_U32, bi) + baseTimestamp + Math.pow(2, bi) - 1\n}\n\n/**\n * Extract the measure from the buffer, handling float case\n */\n\nfunction getMeasure(buffer, sampletype) {\n    var v = buffer.getNextSample(sampletype)\n    return sampletype === ST_FL ? bytes2Float32(v) : v\n}\n\n/**\n * Convert bytes to a float32 representation.\n */\nfunction bytes2Float32(bytes) {\n    var sign = bytes & 0x80000000 ? -1 : 1,\n        exponent = ((bytes >> 23) & 0xff) - 127,\n        significand = bytes & ~(-1 << 23)\n\n    if (exponent == 128) {\n        return sign * (significand ? Number.NaN : Number.POSITIVE_INFINITY)\n    }\n\n    if (exponent == -127) {\n        if (significand === 0) {\n            return sign * 0.0\n        }\n        exponent = -126\n        significand /= 1 << 22\n    } else {\n        significand = (significand | (1 << 23)) / (1 << 23)\n    }\n\n    return sign * significand * Math.pow(2, exponent)\n}\n\n/**\n * Uncompress samples data presenting common timestamp or separate timestamp\n */\nfunction uncompressSamplesData(\n    out,\n    buffer,\n    index_of_the_first_sample,\n    argList,\n    last_timestamp,\n    flag,\n    tagsz\n) {\n    if (flag.isCommonTimestamp) {\n        return handleCommonTimestamp(\n            out,\n            buffer,\n            index_of_the_first_sample,\n            argList,\n            flag,\n            tagsz\n        )\n    }\n    return handleSeparateTimestamp(\n        out,\n        buffer,\n        argList,\n        last_timestamp,\n        flag,\n        tagsz\n    )\n}\n\n/**\n * Uncompress data in case of common timestamp\n */\nfunction handleCommonTimestamp(\n    out,\n    buffer,\n    index_of_the_first_sample,\n    argList,\n    flag,\n    tagsz\n) {\n    //number of sample\n    var nb_sample_to_parse = buffer.getNextSample(ST_U8, 8)\n    var tag = {}\n\n    var temp = initTimestampCommonTable(\n        out,\n        buffer,\n        nb_sample_to_parse,\n        index_of_the_first_sample\n    )\n    var timestampCommon = temp.timestampCommon\n    var lastTimestamp = temp.lastTimestamp\n\n    for (var j = 0; j < flag.nb_of_type_measure; j++) {\n        var first_null_delta_value = 1\n        tag.lbl = buffer.getNextSample(ST_U8, tagsz)\n        var sampleIndex = findIndexFromArgList(argList, tag)\n        for (var i = 0; i < nb_sample_to_parse; i++) {\n            //Available bit\n            var available = buffer.getNextSample(ST_U8, 1)\n            if (available) {\n                //Delta value\n                var bi = buffer.getNextBifromHi(out.series[sampleIndex].codingTable)\n                var currentMeasure = {\n                    data_relative_timestamp: 0,\n                    data: {}\n                }\n                if (bi <= BR_HUFF_MAX_INDEX_TABLE) {\n                    var precedingValue =\n                        out.series[sampleIndex].uncompressSamples[\n                            out.series[sampleIndex].uncompressSamples.length - 1\n                        ].data.value\n                    if (bi > 0) {\n                        currentMeasure.data.value = completeCurrentMeasure(\n                            buffer,\n                            precedingValue,\n                            out.series[sampleIndex].codingType,\n                            argList[sampleIndex].resol,\n                            bi\n                        )\n                    } else {\n                        // (bi <= 0)\n                        if (first_null_delta_value) {\n                            // First value is yet recorded starting from the header\n                            first_null_delta_value = 0\n                            continue\n                        } else {\n                            currentMeasure.data.value = precedingValue\n                        }\n                    }\n                } else {\n                    // bi > BR_HUFF_MAX_INDEX_TABLE\n                    currentMeasure.data.value = buffer.getNextSample(\n                        argList[sampleIndex].sampletype\n                    )\n                }\n                currentMeasure.data_relative_timestamp = timestampCommon[i]\n                out.series[sampleIndex].uncompressSamples.push(currentMeasure)\n            }\n        }\n    }\n    return lastTimestamp\n}\n\n/**\n * Initialize common timestamp table. Returns the table and last calculated timestamp\n */\nfunction initTimestampCommonTable(\n    out,\n    buffer,\n    nbSampleToParse,\n    firstSampleIndex\n) {\n    var timestampCommon = []\n    var lastTimestamp = 0\n    var timestampCoding = buffer.getNextSample(ST_U8, 2)\n    for (var i = 0; i < nbSampleToParse; i++) {\n        //delta timestamp\n        var bi = buffer.getNextBifromHi(timestampCoding)\n        if (bi <= BR_HUFF_MAX_INDEX_TABLE) {\n            if (i === 0) {\n                timestampCommon.push(\n                    out.series[firstSampleIndex].uncompressSamples[0]\n                        .data_relative_timestamp\n                )\n            } else {\n                if (bi > 0) {\n                    var precedingTimestamp = timestampCommon[i - 1]\n                    timestampCommon.push(\n                        buffer.getNextSample(ST_U32, bi) +\n                        precedingTimestamp +\n                        Math.pow(2, bi) -\n                        1\n                    )\n                } else {\n                    timestampCommon.push(precedingTimestamp)\n                }\n            }\n        } else {\n            timestampCommon.push(buffer.getNextSample(ST_U32))\n        }\n        lastTimestamp = timestampCommon[i]\n    }\n    return {\n        timestampCommon: timestampCommon,\n        lastTimestamp: lastTimestamp\n    }\n}\n\n/**\n * Complete current measure from the preceding one\n */\nfunction completeCurrentMeasure(buffer, precedingValue, codingType, resol, bi) {\n    var currentValue = buffer.getNextSample(ST_U16, bi)\n    if (codingType === 0) {\n        // ADLC\n        return computeAdlcValue(currentValue, resol, precedingValue, bi)\n    }\n    if (codingType === 1) {\n        // Positive\n        return (currentValue + Math.pow(2, bi) - 1) * resol + precedingValue\n    }\n    // Negative\n    return precedingValue - (currentValue + (Math.pow(2, bi) - 1)) * resol\n}\n\n/**\n * Return current value in ADLC case\n */\nfunction computeAdlcValue(currentValue, resol, precedingValue, bi) {\n    if (currentValue >= Math.pow(2, bi - 1)) {\n        return currentValue * resol + precedingValue\n    }\n    return (currentValue + 1 - Math.pow(2, bi)) * resol + precedingValue\n}\n\n/**\n * Uncompress data in case of separate timestamp\n */\nfunction handleSeparateTimestamp(\n    out,\n    buffer,\n    argList,\n    last_timestamp,\n    flag,\n    tagsz\n) {\n    var tag = {}\n    for (var i = 0; i < flag.nb_of_type_measure; i++) {\n        tag.lbl = buffer.getNextSample(ST_U8, tagsz)\n        var sampleIndex = findIndexFromArgList(argList, tag)\n        var compressSampleNb = buffer.getNextSample(ST_U8, 8)\n        if (compressSampleNb) {\n            var timestampCoding = buffer.getNextSample(ST_U8, 2)\n            for (var j = 0; j < compressSampleNb; j++) {\n                var precedingRelativeTimestamp =\n                    out.series[sampleIndex].uncompressSamples[\n                        out.series[sampleIndex].uncompressSamples.length - 1\n                    ].data_relative_timestamp\n                var currentMeasure = {\n                    data_relative_timestamp: 0,\n                    data: {}\n                }\n                var bi = buffer.getNextBifromHi(timestampCoding)\n                currentMeasure.data_relative_timestamp = computeTimestampFromBi(\n                    buffer,\n                    precedingRelativeTimestamp,\n                    bi\n                )\n                if (currentMeasure.data_relative_timestamp > last_timestamp) {\n                    last_timestamp = currentMeasure.data_relative_timestamp\n                }\n                bi = buffer.getNextBifromHi(out.series[sampleIndex].codingTable)\n                if (bi <= BR_HUFF_MAX_INDEX_TABLE) {\n                    var precedingValue =\n                        out.series[sampleIndex].uncompressSamples[\n                            out.series[sampleIndex].uncompressSamples.length - 1\n                        ].data.value\n                    if (bi > 0) {\n                        currentMeasure.data.value = completeCurrentMeasure(\n                            buffer,\n                            precedingValue,\n                            out.series[sampleIndex].codingType,\n                            argList[sampleIndex].resol,\n                            bi\n                        )\n                    } else {\n                        // bi <= 0\n                        currentMeasure.data.value = precedingValue\n                    }\n                } else {\n                    // bi > BR_HUFF_MAX_INDEX_TABLE\n                    currentMeasure.data.value = buffer.getNextSample(\n                        argList[sampleIndex].sampletype\n                    )\n                }\n                out.series[sampleIndex].uncompressSamples.push(currentMeasure)\n            }\n        }\n    }\n    return last_timestamp\n}\n\n/**\n * Translate brUncompress output data to expected structure\n */\nfunction adaptToExpectedFormat(out, argList, batchAbsoluteTimestamp) {\n    var returnedGlobalObject = {\n        batch_counter: out.batch_counter,\n        batch_relative_timestamp: out.batch_relative_timestamp\n    }\n    if (batchAbsoluteTimestamp) {\n        returnedGlobalObject.batch_absolute_timestamp = batchAbsoluteTimestamp\n    }\n    returnedGlobalObject.dataset = out.series.reduce(function (\n        acc,\n        current,\n        index\n    ) {\n        return acc.concat(\n            current.uncompressSamples.map(function (item) {\n                var returned = {\n                    data_relative_timestamp: item.data_relative_timestamp,\n                    data: {\n                        value: argList[index].divide\n                            ? item.data.value / argList[index].divide\n                            : item.data.value,\n                        label: argList[index].taglbl\n                    }\n                }\n                if (argList[index].lblname) {\n                    returned.data.label_name = argList[index].lblname\n                }\n                if (batchAbsoluteTimestamp) {\n                    returned.data_absolute_timestamp = computeDataAbsoluteTimestamp(\n                        batchAbsoluteTimestamp,\n                        out.batch_relative_timestamp,\n                        item.data_relative_timestamp\n                    )\n                }\n                return returned\n            })\n        )\n    },\n        [])\n    return returnedGlobalObject\n}\n\n/**\n * Compute data absolute timestamp from batch absolute timestamp (bat), batch\n * relative timestamp (brt) and data relative timestamp (drt)\n */\nfunction computeDataAbsoluteTimestamp(bat, brt, drt) {\n  // @ts-ignore\n  return new Date(new Date(bat) - (brt - drt) * 1000).toISOString()\n}\n\ntry {\n    module.exports = brUncompress\n} catch (e) {\n    // when called from nashorn,  module.exports is unavailableâ€¦\n}\n\n// vim: fdm=marker\n\n\nvar time = new Date().toISOString(); //current time in right time format\n\nvar data = brUncompress(\n    msg.batch_size,  // <<==  the Batch Tag size\n    msg.fields_param,    // From here the batch fileds parameter list\n    msg.payload, // This is the batch frame\n    time\n)\n    ;\nmsg = { payload: data };\n// console.log(msg)\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 100,
        "wires": [
            [
                "491826d4ea340a46"
            ]
        ],
        "icon": "font-awesome/fa-sun-o",
        "info": "## Purpose \r\nThis node decode Lorawan tram received from Watecco sensor\r\n\r\n## Input \r\n```\r\nmsg.payload = \"tram_of_sensor_in_hex\"\r\nmsg.batch_size = int\r\nmsg.fields_param = [the batch fileds parameter list]\r\nmsg.time = ISOString of the batch timestamp\r\n```\r\nThis information could be find  [there](https://lora.watteco.fr/Lora/?trameBatch=QgUABpjPAAAAABF7AAAAgJA9AAAAQNgOysMBIgogwI4IsCMC7IgESBKRJCRJGOQD&timestamp=&BatchAttributes=4+0%2C1%2C10%2CIndex1+1%2C1%2C10%2CIndex2+2%2C1%2C10%2CIndex3+3%2C1%2C1%2CState1+4%2C1%2C1%2CState2+5%2C1%2C1%2CState3+6%2C100%2C6%2CBatteryLevel+7%2C1%2C6%2CMultiState&checkbasebatch=checkox_value&+submit=Submit2)\r\n\r\n**Exemple :** \r\n\r\n```\r\nmsg.payload = \"42070005474f00000000117b00000080903d00000040d80e2ac401220a20c08e08b02302ec880448129124244918e400\"\r\nmsg.batch_size = 4\r\nmsg.payload = new Date().toISOString();\r\nmsg.fields_param = [\r\n    {\r\n      taglbl: 0,\r\n      resol: 1,\r\n      sampletype: 10,\r\n      lblname: \"Index1\"\r\n    },\r\n    {\r\n      taglbl: 1,\r\n      resol: 1,\r\n      sampletype: 10,\r\n      lblname: \"Index2\"\r\n    },\r\n    {\r\n      taglbl: 2,\r\n      resol: 1,\r\n      sampletype: 10,\r\n      lblname: \"Index3\"\r\n    },\r\n    {\r\n      taglbl: 3,\r\n      resol: 1,\r\n      sampletype: 1,\r\n      lblname: \"State1\"\r\n    },\r\n    {\r\n      taglbl: 4,\r\n      resol: 1,\r\n      sampletype: 1,\r\n      lblname: \"State2\"\r\n    },\r\n    {\r\n      taglbl: 5,\r\n      resol: 1,\r\n      sampletype: 1,\r\n      lblname: \"State3\"\r\n    },\r\n    {\r\n      taglbl: 6,\r\n      resol: 100,\r\n      sampletype: 6,\r\n      lblname: \"BatteryLevel\"\r\n    },\r\n    {\r\n      taglbl: 7,\r\n      resol: 1,\r\n      sampletype: 6,\r\n      lblname: \"MultiState\"\r\n    }\r\n  ]\r\n```"
    },
    {
        "id": "a229b509d8298ee1",
        "type": "link in",
        "z": "88c0a23c3a224791",
        "g": "df3290af4eccd44c",
        "name": "data from the Gateway",
        "links": [
            "f7cfa05cd25b46d5"
        ],
        "x": 115,
        "y": 140,
        "wires": [
            [
                "a6e1d5dc445e0c7d"
            ]
        ],
        "info": "# Incoming msg\r\n```\r\nmsg.rx_data JSON object Rx data: \r\n\r\nmsg.rx_data.rx_data_id number Rx data unique identifier, auto incremented \r\n\r\nmsg.rx_data.end_device_id string Device EUI (OTAA) or Device Address (ABP). Hexadecimal value, upper case \r\n\r\nmsg.rx_data.received_time number Reception time, Unix timestamp \r\n\r\nmsg.rx_data.sequence_number number Sequence number \r\n\r\nmsg.rx_data.port number Port in [0;224] \r\n\r\nmsg.rx_data.radio_id number Radio identifier in [0;1] \r\n\r\nmsg.rx_data.channel number Channel identifier in [0;9]. '0' to '7' are the 8 LoRa multi SF channels, '8' is the LoRa mono SF channel, '9' is the FSK channel (RFU) \r\n\r\nmsg.rx_data.snr_db number LoRa SNR ratio in dB \r\n\r\nmsg.rx_data.rssi_dbm number RSSI in dBm \r\n\r\nmsg.rx_data.frequency_hz number Rx central frequency in Hz \r\n\r\nmsg.rx_data.modulation_type string Modulation type 'LoRa' or 'FSK' \r\n\r\nmsg.rx_data.data_rate string If 'LoRa' modulation, 'SFxBWy' format is used where 'x' is spreading factor in [7;12] and 'y' bandwidth in kHz. If 'FSK' modulation, FSK bitrate in bps. \r\n\r\nmsg.rx_data.coding_rate string ECC coding rate (not available with 'FSK' modulation). Always '4/5' \r\n\r\nmsg.rx_data.adr boolean Adaptive data rate \r\n\r\nmsg.rx_data.payload string Payload data. Binary, base64 encoded \r\n\r\n \r\n\r\n```"
    },
    {
        "id": "a6e1d5dc445e0c7d",
        "type": "function",
        "z": "88c0a23c3a224791",
        "g": "df3290af4eccd44c",
        "name": "switch and base 64 to HEX",
        "func": "msg.payload = Buffer.from(msg.rx_data.payload, 'base64')\nmsg.payload = msg.payload.toString('hex')\nmsg._id = msg.rx_data.end_device_id\n\n\nif (msg.rx_data.end_device_id == \"70B3D5E75E014292\"){\n    msg.batch_size = 4\n    msg.fields_param = [\n        {\n            taglbl: 0,\n            resol: 1,\n            sampletype: 10,\n            lblname: \"Index1\"\n        },\n        {\n            taglbl: 1,\n            resol: 1,\n            sampletype: 10,\n            lblname: \"Index2\"\n        },\n        {\n            taglbl: 2,\n            resol: 1,\n            sampletype: 10,\n            lblname: \"Index3\"\n        },\n        {\n            taglbl: 3,\n            resol: 1,\n            sampletype: 1,\n            lblname: \"State1\"\n        },\n        {\n            taglbl: 4,\n            resol: 1,\n            sampletype: 1,\n            lblname: \"State2\"\n        },\n        {\n            taglbl: 5,\n            resol: 1,\n            sampletype: 1,\n            lblname: \"State3\"\n        },\n        {\n            taglbl: 6,\n            resol: 100,\n            sampletype: 6,\n            lblname: \"BatteryLevel\"\n        },\n        {\n            taglbl: 7,\n            resol: 1,\n            sampletype: 6,\n            lblname: \"MultiState\"\n        }\n    ]\n    msg.time = msg.rx_data.received_time\n\n    return[msg,null]\n\n}\n\nelse if (msg.rx_data.end_device_id === \"70B3D5E75E019F10\"){\n    return[null,msg]\n}\n\nelse {\n    node.warn(\"Unknow device : \" + msg.rx_data.end_device_id)\n}\n// return msg;",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 140,
        "wires": [
            [
                "9e9fdffdcf93cb78"
            ],
            [
                "642c9077cfcdc2fa"
            ]
        ],
        "outputLabels": [
            "watteco",
            "TIC"
        ]
    },
    {
        "id": "642c9077cfcdc2fa",
        "type": "function",
        "z": "88c0a23c3a224791",
        "g": "df3290af4eccd44c",
        "name": "TIc decoder",
        "func": "// @ts-nocheck\n/*\n * A javascript template to decode a nke Watteco ZCL \"like\" standard payload at a given port\n *\n * Notice trhat this template is volontary very simple to be easiliy embedable in many javascript environnemnts\n * That's why it willingly does not uses any specific API like (Buffer from Node.js, or npm, or any..)\n *\n * Basically it can be test as it is in TTN \"payload formats decoder\"\n *\n */\n\n/*\n * To test simply present codec template on any computer, install Node.js (https://nodejs.org/en/) \n * \n * Then you can try decoding ZCL frames, by uncommenting first three lines below and \n * and then use commands like these in you \"terminal/command\" window:\n *\n *     node decodeZCL.js 125 110A04020000290998\n *     node decodeZCL.js 125 1101800F80000041170064271080031B5800A000A00136000003E84E20901407\n *\n * You could also set the three following lines commented to implement you own Decoder(...) function calls...\n *\n */\n\n// var argv= process.argv.slice(2);\n// obj = Decoder(Buffer.from(argv[1],'hex'),parseInt(argv[0], 10 ));\nvar port = (msg.hasOwnProperty('port')) ? msg.port : 125\nvar obj = Decoder(Buffer.from(msg.payload, 'hex'), parseInt(port, 10));\nreturn { payload: obj }\n\n// ----------------------------------------------------------------\n// ----------------------- FUNCTIONS PART (Deprecated) ------------\n// ----------------------------------------------------------------\nfunction UintToInt(Uint, Size) {\n    if (Size === 2) {\n        if ((Uint & 0x8000) > 0) {\n            Uint = Uint - 0x10000;\n        }\n    }\n    if (Size === 3) {\n        if ((Uint & 0x800000) > 0) {\n            Uint = Uint - 0x1000000;\n        }\n    }\n    if (Size === 4) {\n        if ((Uint & 0x80000000) > 0) {\n            Uint = Uint - 0x100000000;\n        }\n    }\n\n\n    return Uint;\n}\n\nfunction Bytes2Float32(bytes) {\n    var sign = (bytes & 0x80000000) ? -1 : 1;\n    var exponent = ((bytes >> 23) & 0xFF) - 127;\n    var significand = (bytes & ~(-1 << 23));\n\n    if (exponent == 128)\n        return sign * ((significand) ? Number.NaN : Number.POSITIVE_INFINITY);\n\n    if (exponent == -127) {\n        if (significand == 0) return sign * 0.0;\n        exponent = -126;\n        significand /= (1 << 23);\n    } else significand = (significand | (1 << 23)) / (1 << 23);\n\n    return sign * significand * Math.pow(2, exponent);\n}\n\n// ----------------------------------------------------------------\n// ----------------------- FUNCTIONS PART -------------------------\n// ----------------------------------------------------------------\n\n/*\n * Int conversion directly from buffer with start index and required endianess \n *\n * Type must be     : U8,I8,U16,I16,U24,I24,U32,I32,U40,I40,...,U56,I56,I64\n * LittleEndian if true either big endian\n */\nfunction BytesToInt64(InBytes, StartIndex, Type, LittleEndian) {\n    if (typeof (LittleEndian) == 'undefined') LittleEndian = false;\n\n    var Signed = (Type.substr(0, 1) != \"U\");\n    var BytesNb = parseInt(Type.substr(1, 2), 10) / 8;\n    var inc, start;\n    var nb = BytesNb;\n\n    if (LittleEndian) {\n        inc = -1;\n        start = StartIndex + BytesNb - 1;\n    }\n    else {\n        inc = 1; start = StartIndex;\n    }\n\n    let tmpInt64 = 0;\n    for (let j = start; nb > 0; (j += inc, nb--)) {\n        tmpInt64 = (tmpInt64 << 8) + InBytes[j];\n    }\n\n    if ((Signed) && (BytesNb < 8) && (InBytes[start] & 0x80))\n        tmpInt64 = tmpInt64 - (0x01 << (BytesNb * 8));\n\n    return tmpInt64;\n}\n\n/*\n * Float32 conversion directly from buffer with start index and required endianess \n *\n * LittleEndian if true either big endian\n */\nfunction BytesToFloat32(InBytes, StartIndex, LittleEndian) {\n\n    if (typeof (LittleEndian) == 'undefined') LittleEndian = false;\n\n    var buf = InBytes.slice(StartIndex, StartIndex + 4);\n    if (!LittleEndian) buf.reverse();\n    var f32a = new Float32Array((new Int8Array(buf)).buffer);\n    return f32a[0];\n}\n\n\nfunction decimalToHex(d, padding) {\n    var hex = Number(d).toString(16).toUpperCase();\n    padding = typeof (padding) === \"undefined\" || padding === null ? padding = 2 : padding;\n\n    while (hex.length < padding) {\n        hex = \"0\" + hex;\n    }\n\n    return \"0x\" + hex;\n}\n\nfunction parseHexString(str) {\n    var result = [];\n    while (str.length >= 2) {\n        result.push(parseInt(str.substring(0, 2), 16));\n\n        str = str.substring(2, str.length);\n    }\n\n    return result;\n}\n\nfunction byteToHex(b) {\n    const hexChar = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n    return hexChar[(b >> 4) & 0x0f] + hexChar[b & 0x0f];\n}\n\nfunction BytesToHexStr(buff) {\n    const hexOctets = [];\n    for (let i = 0; i < buff.length; ++i) {\n        hexOctets.push(byteToHex(buff[i]));\n    }\n    return hexOctets.join(\"\");\n}\n\nfunction zeroPad(num, places) {\n    return (String(num).padStart(places, '0'));\n}\n\n\n\n/* \n * ===============================================================================\n * TIC specific part\n * ===============================================================================\n */\n\n\nfunction TIC_Decode(ClusterID, AttributeID, BytesAfterSize) {\n\n    // GENERIC ENUMs Management\n    //-------------------------\n    const E_DIV =\n        [\"!?!\", \"*\", \"\",\n            \" ACTIF\", \"ACTIF\", \"CONSO\", \"CONTROLE\", \"DEP\", \"INACTIF\", \"PROD\", \"TEST\", \"kVA\", \"kW\"];\n    const E_PT =\n        [\"!?!\", \"*\", \"\",\n            \" ? \", \"000\", \"HC\", \"HCD\", \"HCE\", \"HCH\", \"HH\", \"HH \", \"HP\", \"HP \", \"HPD\", \"HPE\", \"HPH\", \"JA\", \"JA \", \"P\", \"P  \", \"PM\", \"PM \", \"XXX\"];\n    const E_CONTRAT =\n        [\"!?!\", \"*\", \"\",\n            \"BT 4 SUP36\", \"BT 5 SUP36\", \"HTA 5     \", \"HTA 8     \",\n            \"TJ EJP    \", \"TJ EJP-HH \", \"TJ EJP-PM \", \"TJ EJP-SD \", \"TJ LU     \",\n            \"TJ LU-CH  \", \"TJ LU-P   \", \"TJ LU-PH  \", \"TJ LU-SD  \", \"TJ MU     \",\n            \"TV A5 BASE\", \"TV A8 BASE\",\n            \"BASE\", \"H PLEINE-CREUSE\", \"HPHC\", \"HC\", \"HC et Week-End\", \"EJP\", \"PRODUCTEUR\"];\n    const E_STD_PT =\n        [\"!?!\", \"*\", \"\",\n            \" ? \",\n            \"000\", \"HC\", \"HCD\", \"HCE\", \"HCH\", \"HH\", \"HH \", \"HP\", \"HP \",\n            \"HPD\", \"HPE\", \"HPH\", \"JA\", \"JA \", \"P\", \"P  \", \"PM\", \"PM \", \"XXX\",\n            \"INDEX NON CONSO\", \"BASE\", \"HEURE CREUSE\", \"HEURE PLEINE\", \"HEURE NORMALE\", \"HEURE POINTE\",\n            \"HC BLEU\", \"BUHC\", \"HP BLEU\", \"BUHP\", \"HC BLANC\", \"BCHC\", \"HP BLANC\", \"BCHP\", \"HC ROUGE\", \"RHC\", \"HP ROUGE\", \"RHP\",\n            \"HEURE WEEK-END\"];\n    const E_STD_CONTRAT =\n        [\"!?!\", \"*\", \"\",\n            \"BT 4 SUP36\", \"BT 5 SUP36\", \"HTA 5     \", \"HTA 8     \",\n            \"TJ EJP    \", \"TJ EJP-HH \", \"TJ EJP-PM \", \"TJ EJP-SD \", \"TJ LU     \",\n            \"TJ LU-CH  \", \"TJ LU-P   \", \"TJ LU-PH  \", \"TJ LU-SD  \", \"TJ MU     \",\n            \"TV A5 BASE\", \"TV A8 BASE\",\n            \"BASE\", \"H PLEINE-CREUSE\", \"HPHC\", \"HC\", \"HC et Week-End\", \"EJP\", \"PRODUCTEUR\"\n            /* Todo: Add necessary Enums when known */\n        ];\n\n    function TICParseEnum(Bytes, i, Enums) {\n        var x = {};\n        if ((Bytes[i] & 0x80) == 0) { // Really Enum\n            let iEnum = Bytes[i] & 0x7F;\n\n            // Palliatif Anomalie 3.5.0.4852 à 3.5.0.5339 (Cf http://support.nke-watteco.com/tic/)\n            // Ligne à commenter si le capteur PMEPMI a une version firmware différente de ci-dessus\n            iEnum++;\n\n            x = Enums[iEnum]; i += 1;\n        } else { // NString\n            let sz = Bytes[i] & 0x7F; i += 1;\n            if (sz > 0) {\n                x = String.fromCharCode.apply(null, Bytes.slice(i, i + sz)); i += sz;\n            } else {\n                x = \"\";\n            }\n        }\n        return { x, i }\n    }\n\n    // DESCRIPTOR Parser\n    //------------------\n    function TICParseDescToIndexes(DescIn) {\n\n        var Indexes = [];\n\n        var DescHeader = DescIn[0];\n        var DescSize = (DescHeader & 0x1F);\n        if (DescSize == 0) {\n            DescSize = 8; // Historical fixed size Descriptor\n        }\n        let IsVarIndexes = ((DescHeader & 0x20) != 0);\n\n        if (IsVarIndexes) {\n            for (i = 1; i < DescSize; i++) {\n                Indexes.push(DescIn[i]);\n            }\n        } else {\n            // is VarBitfields\n            let iField = 0;\n            // TODO if historical: 7 LSbit of first byte should be used ... TODO\n            for (var i = DescSize; i > 1; i--) {\n                for (let b = 0; b < 8; b++) {\n                    if ((DescIn[i - 1] >> b) & 0x01) {\n                        Indexes.push(iField);\n                    }\n                    iField++;\n                }\n            }\n        }\n\n        return { DescSize, Indexes }\n    }\n\n    function TICParseDMYhms(b, i) {\n        x = zeroPad(BytesToInt64(b, i, \"U8\"), 2) + \"/\" + zeroPad(BytesToInt64(b, i + 1, \"U8\"), 2) + \"/\" + zeroPad(BytesToInt64(b, i + 2, \"U8\"), 2) + \" \" +\n            zeroPad(BytesToInt64(b, i + 3, \"U8\"), 2) + \":\" + zeroPad(BytesToInt64(b, i + 4, \"U8\"), 2) + \":\" + zeroPad(BytesToInt64(b, i + 5, \"U8\"), 2);\n        i += 6;\n        return { x, i }\n    }\n\n    function TICParseTimeStamp(b, i, LittleEndian) {\n        // EPOCH TIC: 01/01/2000 00:00:00\n        // EPOCH UNIX: 01/01/1970 00:00:00\n        let ts = BytesToInt64(b, i, \"U32\", LittleEndian); i += 4;\n        ts += (new Date(\"2000/01/01 00:00:00\").getTime() / 1000)\n        ts += 3600; //TODO: find a way to beter manage this 1h shift due to TZ and DST of running computer\n        var a = new Date(ts * 1000);\n        var x =\n            zeroPad(a.getDate(), 2) + '/' + zeroPad(a.getMonth(), 2) + '/' + a.getFullYear() + ' ' +\n            zeroPad(a.getHours(), 2) + ':' + zeroPad(a.getMinutes(), 2) + ':' + zeroPad(a.getSeconds(), 2);\n        return { x, i };\n    }\n\n    function TICParseCString(b, i) {\n        let eos = b.slice(i).indexOf(0);\n        x = String.fromCharCode.apply(null, b.slice(i, i + eos)); i += (eos + 1);\n        return { x, i }\n    }\n\n    function TICParseNString(b, i, n) {\n        x = String.fromCharCode.apply(null, b.slice(i, i + n)); i += n;\n        return { x, i }\n    }\n\n\n\n    // ---------------------------------------------------------\n    // FIELD PARSING\n    function TYPE_EMPTY(b, i) { return { b, i }; }\n    function TYPE_CHAR(b, i) {\n        x = String.fromCharCode.apply(null, b.slice(0, 1)); i += 1;\n        return { x, i }\n    }\n    function TYPE_CSTRING(b, i) { return TICParseCString(b, i); }\n    function TYPE_U8(b, i) { x = BytesToInt64(b, i, \"U8\"); i += 1; return { x, i } }\n    function TYPE_U16(b, i) { x = BytesToInt64(b, i, \"U16\"); i += 2; return { x, i } }\n    function TYPE_I16(b, i) { x = BytesToInt64(b, i, \"I16\"); i += 2; return { x, i } }\n    function TYPE_U24CSTRING(b, i) {\n        var x = {};\n        x[\"Value\"] = BytesToInt64(b, i, \"U24\"); i += 3;\n        let s = TICParseCString(b, i);\n        x[\"Label\"] = s.x; i = s.i;\n        return { x, i }\n    };\n    function TYPE_U24(b, i) { x = BytesToInt64(b, i, \"U24\"); i += 3; return { x, i } }\n    function TYPE_4U24(b, i) {\n        var x = {};\n        for (i = 1; i <= 4; i++) { x[\"Value_\" + i] = BytesToInt64(b, i, \"U24\"); i += 3; }\n        return { x, i }\n    };\n    function TYPE_6U24(b, i) {\n        var x = {};\n        for (i = 1; i <= 4; i++) { x[\"Value_\" + i] = BytesToInt64(b, i, \"U24\"); i += 3; }\n        return { x, i }\n    }\n    function TYPE_U32(b, i) { x = BytesToInt64(b, i, \"U32\"); i += 4; return { x, i } }\n    function TYPE_FLOAT(b, i) { x = BytesToFloat32(b, i); i += 4; return { x, i } }\n    function TYPE_DMYhms(b, i) { return TICParseDMYhms(b, i); }\n    function TYPE_tsDMYhms(b, i) { return TICParseTimeStamp(b, i); };\n    function TYPE_DMYhmsCSTRING(b, i) {\n        var x = {};\n        var d = TICParseDMYhms(b, i); x[\"Date\"] = d.x;;\n        var s = TICParseCString(b, d.i); x[\"Label\"] = s.x;\n        i = s.i;\n        return { x, i };\n    }\n    function TYPE_E_PT(b, i) { return TICParseEnum(b, i, E_PT); }\n    function TYPE_E_STD_PT(b, i) { return TICParseEnum(b, i, E_STD_PT); }\n    function TYPE_tsDMYhms_E_PT(b, i) {\n        var x = {};\n        var d = TICParseTimeStamp(b, i);\n        var e = TICParseEnum(b, d.i, E_PT);\n        i = e.i;\n        return { x, i }\n    }\n    function TYPE_hmDM(b, i) {\n        var x = {};\n        let h = zeroPad(BytesToInt64(b, i, \"U8\"), 2); i++;\n        let m = zeroPad(BytesToInt64(b, i, \"U8\"), 2); i++;\n        let D = zeroPad(BytesToInt64(b, i, \"U8\"), 2); i++;\n        let M = zeroPad(BytesToInt64(b, i, \"U8\"), 2); i++;\n        x = D + \"/\" + M + \" \" + h + \":\" + m;\n        return { x, i }\n    }\n    function TYPE_DMh(b, i) {\n        var x = {};\n        let D = zeroPad(BytesToInt64(b, i, \"U8\"), 2); i++;\n        let M = zeroPad(BytesToInt64(b, i, \"U8\"), 2); i++;\n        let h = zeroPad(BytesToInt64(b, i, \"U8\"), 2); i++;\n        x = D + \"/\" + M + \" \" + h;\n        return { x, i }\n    }\n    function TYPE_hm(b, i) {\n        var x = {};\n        let h = zeroPad(BytesToInt64(b, i, \"U8\"), 2); i++;\n        let m = zeroPad(BytesToInt64(b, i, \"U8\"), 2); i++;\n        x = h + \":\" + m;\n        return { x, i }\n    }\n    function TYPE_SDMYhms(b, i) {\n        var x = {};\n        let s = TICParseNString(b, i, 1);\n        let d = TICParseDMYhms(b, s.i);\n        x[\"S\"] = s.x;\n        x[\"Date\"] = d.x;\n        i = d.i;\n        return { x, i }\n    }\n    function TYPE_SDMYhmsU8(b, i) {\n        var x = {};\n        let s = TICParseNString(b, i, 1);\n        let d = TICParseDMYhms(b, s.i);\n        let n = BytesToInt64(b, i, \"U8\"); i = d.i + 1;\n        x[\"S\"] = s.x;\n        x[\"Date\"] = d.x;\n        x[\"Value\"] = n;\n        return { x, i }\n    }\n    function TYPE_SDMYhmsU16(b, i) {\n        var x = {};\n        let s = TICParseNString(b, i, 1);\n        let d = TICParseDMYhms(b, s.i);\n        let n = BytesToInt64(b, i, \"U16\"); i = d.i + 1;\n        x[\"S\"] = s.x;\n        x[\"Date\"] = d.x;\n        x[\"Value\"] = n;\n        return { x, i }\n    }\n    function TYPE_SDMYhmsU24(b, i) {\n        var x = {};\n        let s = TICParseNString(b, i, 1);\n        let d = TICParseDMYhms(b, s.i);\n        let n = BytesToInt64(b, i, \"U24\"); i = d.i + 1;\n        x[\"S\"] = s.x;\n        x[\"Date\"] = d.x;\n        x[\"Value\"] = n;\n        return { x, i }\n    }\n    function TYPE_BF32xbe(b, i) {\n        var x = BytesToHexStr(b.slice(i, 2)); i += 4;\n        i += 4\n        return { x, i }\n    }   /* Bitfield 32 bits heXa Big Endian */\n    function TYPE_HEXSTRING(b, i) {\n        var x = BytesToHexStr(b.slice(i + 1, i + 1 + b[i]));\n        i += b[i] + 1;\n        let d = { x, i }\n        return { x, i }\n    }/* displayed as hexadecimal string Stored as <Size>+<byte string> */\n    function TYPE_E_DIV(b, i) { return TICParseEnum(b, i, E_DIV); }\n    function TYPE_U24_E_DIV(b, i) {\n        var x = {};\n        let dd = BytesToInt64(b, i, \"U24\"); i += 3;\n        x.Value = dd;\n        let e = TICParseEnum(b, i, E_DIV);\n        x.Label = e.x; i = e.i;\n        return { x, i }\n    }\n    function TYPE_E_CONTRAT(b, i) { return TICParseEnum(b, i, E_CONTRAT); }\n    function TYPE_E_STD_CONTRAT(b, i) { return TICParseEnum(b, i, E_STD_CONTRAT); }\n    function TYPE_11hhmmSSSS(b, i) {\n        var x = []\n        for (var j = 0; j < 11; j++) {\n            let y = {};\n            let h = zeroPad(BytesToInt64(b, i, \"U8\"), 2); i++;\n            if (h == 0xFF) {\n                y[\"Status\"] = \"NONUTILE\"\n            } else {\n                let m = zeroPad(BytesToInt64(b, i, \"U8\"), 2); i++;\n                let s = BytesToHexStr(b.slice(i, 2)); i++;\n                y[\"Time\"] = h + \":\" + m;\n                y[\"Status\"] = s;\n                i += b[i] + 1;\n            }\n            x.push(y);\n        }\n        return { x, i }\n    } /* New type for PJOURF+1 / PPOINTE of Linky. */\n    /* 11 Blocs of 8 Bytes (hhmmSSSS) space separated values are compressed as follow */\n    /* hh 1 byte Hour, mm 1 byte Minute, SSSS two bytes bitfield */\n    /* Notes: */\n    /* - Delta comparison: */\n    /*   hh and mm are usual for delta comparison */\n    /*   SSSS is compared as bitfield each bit set may trig an event if changed */\n    /* - An unused field is defined as follow: */\n    /*   hh = 0xFF and No other bytes used in the binarized form */\n    /*   \"NONUTILE\" string in the TIC ASCII format */\n    function TYPE_BF8d(b, i) {\n        x = BytesToInt64(b, i, \"U8\"); i++;\n        return { x, i }\n    }\t\t/* Bitfield de 8 bit with TIC decimal representation (0 à 255) */\n\n\n\n    // ---------------------------------------------------------\n    // OUTPUT FORMATS\n    // TODO ... At the moment format are not used (Cf c language TIC decoder)\n    function FMT_UNDEF(x) { return (x); };\n\n    function FMT_s(x) { return (x); }; // %s \n    function FMT_PREAVIS_PT(x) { return (x); }; // TD-%s \n    function FMT_c(x) { return (x); }; // %c \n    function FMT_02X(x) { return (x); }; // %02x \n    function FMT_d(x) { return (x); }; // %d \n    function FMT_ld(x) { return (x); }; // %ld \n\n    function FMT_02d(x) { return (x); }; // %02d \n    function FMT_03d(x) { return (x); }; // %03d \n    function FMT_05d(x) { return (x); }; // %05d \n    /*\n        function FMT_07d(x)   { return(x); // %07d\n        function FMT_09d(x)   { return(x); // %09d\n    */\n    function FMT_05ld(x) { return (x); }; // %05d\n    function FMT_06ld(x) { return (x); }; // %06d\n    function FMT_07ld(x) { return (x); }; // %07d\n    function FMT_09ld(x) { return (x); }; // %09d\n\n    function FMT_d_percent(x) { return (x); }; // %d%%\n\n    function FMT_d_s(x) { return (x); }; //%ds\n\n    function FMT_d_kW(x) { return (x); }; // %dkW\n    function FMT_d_kvar(x) { return (x); }; // %dkvar\n\n    function FMT_05d_kwh(x) { return (x); }; // %05ldkwh\n    function FMT_ld_Wh(x) { return (x); }; // %ldWh\n    function FMT_05ld_Wh(x) { return (x); }; // 05ldWh\n    function FMT_05ld_varh(x) { return (x); }; // %05ldvarh\n    function FMT_ld_varh(x) { return (x); }; // %ldvarh\n    function FMT_ld_VAh(x) { return (x); }; // %ldVAh\n\n    function FMT_d_V(x) { return (x); }; // %dV\n\n    function FMT_d_kWh(x) { return (x); }; // %dkWh\n    function FMT_ld_kWh(x) { return (x); }; // %07ldkWh\n    function FMT_d_kvarh(x) { return (x); }; // %dkvarh\n    function FMT_ld_kvarh(x) { return (x); }; // %07ldkvarh\n\n    function FMT_05_2f(x) { return (x); }; // %05.2f\"\n\n    // ============================================\n    // PROFILS DEFINITION\n    // ============================================\n\n    // ClusterID: 0x0053, Attribute ID : 0xii00\n    //-----------------------------------------\n    const ICE_General = [\n        [\"CONTRAT\", TYPE_CSTRING, 0, FMT_s],\n        [\"DATECOUR\", TYPE_DMYhms, 0, FMT_UNDEF],\n        [\"DATE\", TYPE_DMYhms, 0, FMT_UNDEF],\n        [\"EA\", TYPE_U24, 0, FMT_05ld_Wh],\n        [\"ERP\", TYPE_U24, 0, FMT_05ld_varh],\n        [\"PTCOUR\", TYPE_CSTRING, 0, FMT_s],\n        [\"PREAVIS\", TYPE_CSTRING, 0, FMT_s],\n        [\"MODE\", TYPE_EMPTY, 0, FMT_s],\n        // Byte 1\n        [\"DATEPA1\", TYPE_DMYhms, 0, FMT_UNDEF],\n        [\"PA1\", TYPE_U16, 0, FMT_d_kW],\n        [\"DATEPA2\", TYPE_DMYhms, 0, FMT_UNDEF],\n        [\"PA2\", TYPE_U16, 0, FMT_d_kW],\n        [\"DATEPA3\", TYPE_DMYhms, 0, FMT_UNDEF],\n        [\"PA3\", TYPE_U16, 0, FMT_d_kW],\n        [\"DATEPA4\", TYPE_DMYhms, 0, FMT_UNDEF],\n        [\"PA4\", TYPE_U16, 0, FMT_d_kW],\n        // Byte 2\n        [\"DATEPA5\", TYPE_DMYhms, 0, FMT_UNDEF],\n        [\"PA5\", TYPE_U16, 0, FMT_d_kW],\n        [\"DATEPA6\", TYPE_DMYhms, 0, FMT_UNDEF],\n        [\"PA6\", TYPE_U16, 0, FMT_d_kW],\n        [\"*p*\", TYPE_U24, 0, FMT_05ld],\n        //[\"*p*\",\tTYPE_U24,ATTRIBUTE_NOT_MANAGED_FIELD,FMT_05ld],\n        [\"KDC\", TYPE_U8, 0, FMT_d_percent],\n        [\"KDCD\", TYPE_U8, 0, FMT_d_percent],\n        [\"TGPHI\", TYPE_FLOAT, 0, FMT_05_2f],\n        // Byte 3\n        [\"PSP\", TYPE_U16, 0, FMT_d_kW],\n        [\"PSPM\", TYPE_U16, 0, FMT_d_kW],\n        [\"PSHPH\", TYPE_U16, 0, FMT_d_kW],\n        [\"PSHPD\", TYPE_U16, 0, FMT_d_kW],\n        [\"PSHCH\", TYPE_U16, 0, FMT_d_kW],\n        [\"PSHCD\", TYPE_U16, 0, FMT_d_kW],\n        [\"PSHPE\", TYPE_U16, 0, FMT_d_kW],\n        [\"PSHCE\", TYPE_U16, 0, FMT_d_kW],\n        // Byte 4\n        [\"PSJA\", TYPE_U16, 0, FMT_d_kW],\n        [\"PSHH\", TYPE_U16, 0, FMT_d_kW],\n        [\"PSHD\", TYPE_U16, 0, FMT_d_kW],\n        [\"PSHM\", TYPE_U16, 0, FMT_d_kW],\n        [\"PSDSM\", TYPE_U16, 0, FMT_d_kW],\n        [\"PSSCM\", TYPE_U16, 0, FMT_d_kW],\n        [\"MODE\", TYPE_EMPTY, 0, FMT_s],\n        [\"PA1MN\", TYPE_U16, 0, FMT_d_kW],\n        // Byte 5\n        [\"PA10MN\", TYPE_U16, 0, FMT_d_kW],\n        [\"PREA1MN\", TYPE_I16, 0, FMT_d_kvar],\n        [\"PREA10MN\", TYPE_I16, 0, FMT_d_kvar],\n        [\"TGPHI\", TYPE_FLOAT, 0, FMT_05_2f],\n        [\"U10MN\", TYPE_U16, 0, FMT_d_V]\n    ];\n\n    // ClusterID: 0x0053, Attribute ID : 0xii01\n    //-----------------------------------------\n    const ICE_p = [\n        //Byte 0\n        [\"DEBUTp\", TYPE_DMYhms, 0, FMT_UNDEF, 0],\n        [\"FINp\", TYPE_DMYhms, 0, FMT_UNDEF, 6],\n        [\"CAFp\", TYPE_U16, 0, FMT_05d, 12],\n\n        [\"DATEEAp\", TYPE_DMYhms, 0, FMT_UNDEF, 14],\n        [\"EApP\", TYPE_U24, 0, FMT_ld_kWh, 20],\n        [\"EApPM\", TYPE_U24, 0, FMT_ld_kWh, 23],\n        [\"EApHCE\", TYPE_U24, 0, FMT_ld_kWh, 26],\n        [\"EApHCH\", TYPE_U24, 0, FMT_ld_kWh, 29],\n        //Byte 1\n        [\"EApHH\", TYPE_U24, 0, FMT_ld_kWh, 32],\n        [\"EApHCD\", TYPE_U24, 0, FMT_ld_kWh, 35],\n        [\"EApHD\", TYPE_U24, 0, FMT_ld_kWh, 38],\n        [\"EApJA\", TYPE_U24, 0, FMT_ld_kWh, 41],\n        [\"EApHPE\", TYPE_U24, 0, FMT_ld_kWh, 44],\n        [\"EApHPH\", TYPE_U24, 0, FMT_ld_kWh, 47],\n        [\"EApHPD\", TYPE_U24, 0, FMT_ld_kWh, 50],\n        [\"EApSCM\", TYPE_U24, 0, FMT_ld_kWh, 53],\n        // Byte 2\n        [\"EApHM\", TYPE_U24, 0, FMT_ld_kWh, 56],\n        [\"EApDSM\", TYPE_U24, 0, FMT_ld_kWh, 59],\n\n        [\"DATEERPp\", TYPE_DMYhms, 0, FMT_UNDEF, 62],\n        [\"ERPpP\", TYPE_U24, 0, FMT_ld_kvarh, 68],\n        [\"ERPpPM\", TYPE_U24, 0, FMT_ld_kvarh, 71],\n        [\"ERPpHCE\", TYPE_U24, 0, FMT_ld_kvarh, 74],\n        [\"ERPpHCH\", TYPE_U24, 0, FMT_ld_kvarh, 77],\n        [\"ERPpHH\", TYPE_U24, 0, FMT_ld_kvarh, 80],\n        // Byte 3\n        [\"ERPpHCD\", TYPE_U24, 0, FMT_ld_kvarh, 83],\n        [\"ERPpHD\", TYPE_U24, 0, FMT_ld_kvarh, 86],\n        [\"ERPpJA\", TYPE_U24, 0, FMT_ld_kvarh, 89],\n        [\"ERPpHPE\", TYPE_U24, 0, FMT_ld_kvarh, 92],\n        [\"ERPpHPH\", TYPE_U24, 0, FMT_ld_kvarh, 95],\n        [\"ERPpHPD\", TYPE_U24, 0, FMT_ld_kvarh, 98],\n        [\"ERPpSCM\", TYPE_U24, 0, FMT_ld_kvarh, 101],\n        [\"ERPpHM\", TYPE_U24, 0, FMT_ld_kvarh, 104],\n        // Byte 4\n        [\"ERPpDSM\", TYPE_U24, 0, FMT_ld_kvarh, 107],\n\n        [\"DATEERNp\", TYPE_DMYhms, 0, FMT_UNDEF, 110],\n        [\"ERNpP\", TYPE_U24, 0, FMT_ld_kvarh, 116],\n        [\"ERNpPM\", TYPE_U24, 0, FMT_ld_kvarh, 119],\n        [\"ERNpHCE\", TYPE_U24, 0, FMT_ld_kvarh, 122],\n        [\"ERNpHCH\", TYPE_U24, 0, FMT_ld_kvarh, 125],\n        [\"ERNpHH\", TYPE_U24, 0, FMT_ld_kvarh, 128],\n        [\"ERNpHCD\", TYPE_U24, 0, FMT_ld_kvarh, 131],\n        // Byte 5\n        [\"ERNpHD\", TYPE_U24, 0, FMT_ld_kvarh, 134],\n        [\"ERNpJA\", TYPE_U24, 0, FMT_ld_kvarh, 137],\n        [\"ERNpHPE\", TYPE_U24, 0, FMT_ld_kvarh, 140],\n        [\"ERNpHPH\", TYPE_U24, 0, FMT_ld_kvarh, 143],\n        [\"ERNpHPD\", TYPE_U24, 0, FMT_ld_kvarh, 146],\n        [\"ERNpSCM\", TYPE_U24, 0, FMT_ld_kvarh, 149],\n        [\"ERNpHM\", TYPE_U24, 0, FMT_ld_kvarh, 152],\n        [\"ERNpDSM\", TYPE_U24, 0, FMT_ld_kvarh, 155]\n        // Byte 6\n    ];\n\n    // ClusterID: 0x0053, Attribute ID : 0xii02\n    //-----------------------------------------\n    const ICE_p1 = [\n        //Byte 0\n        [\"DEBUTp1\", TYPE_DMYhms, 0, FMT_UNDEF, 0],\n        [\"FINp1\", TYPE_DMYhms, 0, FMT_UNDEF, 6],\n        [\"CAFp1\", TYPE_U16, 0, FMT_05d, 12],\n\n        [\"DATEEAp1\", TYPE_DMYhms, 0, FMT_UNDEF, 14],\n        [\"EAp1P\", TYPE_U24, 0, FMT_ld_kWh, 20],\n        [\"EAp1PM\", TYPE_U24, 0, FMT_ld_kWh, 23],\n        [\"EAp1HCE\", TYPE_U24, 0, FMT_ld_kWh, 26],\n        [\"EAp1HCH\", TYPE_U24, 0, FMT_ld_kWh, 29],\n        //Byte 1\n        [\"EAp1HH\", TYPE_U24, 0, FMT_ld_kWh, 32],\n        [\"EAp1HCD\", TYPE_U24, 0, FMT_ld_kWh, 35],\n        [\"EAp1HD\", TYPE_U24, 0, FMT_ld_kWh, 38],\n        [\"EAp1JA\", TYPE_U24, 0, FMT_ld_kWh, 41],\n        [\"EAp1HPE\", TYPE_U24, 0, FMT_ld_kWh, 44],\n        [\"EAp1HPH\", TYPE_U24, 0, FMT_ld_kWh, 47],\n        [\"EAp1HPD\", TYPE_U24, 0, FMT_ld_kWh, 50],\n        [\"EAp1SCM\", TYPE_U24, 0, FMT_ld_kWh, 53],\n        // Byte 2\n        [\"EAp1HM\", TYPE_U24, 0, FMT_ld_kWh, 56],\n        [\"EAp1DSM\", TYPE_U24, 0, FMT_ld_kWh, 59],\n\n        [\"DATEERPp1\", TYPE_DMYhms, 0, FMT_UNDEF, 62],\n        [\"ERPp1P\", TYPE_U24, 0, FMT_ld_kvarh, 68],\n        [\"ERPp1PM\", TYPE_U24, 0, FMT_ld_kvarh, 71],\n        [\"ERPp1HCE\", TYPE_U24, 0, FMT_ld_kvarh, 74],\n        [\"ERPp1HCH\", TYPE_U24, 0, FMT_ld_kvarh, 77],\n        [\"ERPp1HH\", TYPE_U24, 0, FMT_ld_kvarh, 80],\n        // Byte 3\n        [\"ERPp1HCD\", TYPE_U24, 0, FMT_ld_kvarh, 83],\n        [\"ERPp1HD\", TYPE_U24, 0, FMT_ld_kvarh, 86],\n        [\"ERPp1JA\", TYPE_U24, 0, FMT_ld_kvarh, 89],\n        [\"ERPp1HPE\", TYPE_U24, 0, FMT_ld_kvarh, 92],\n        [\"ERPp1HPH\", TYPE_U24, 0, FMT_ld_kvarh, 95],\n        [\"ERPp1HPD\", TYPE_U24, 0, FMT_ld_kvarh, 98],\n        [\"ERPp1SCM\", TYPE_U24, 0, FMT_ld_kvarh, 101],\n        [\"ERPp1HM\", TYPE_U24, 0, FMT_ld_kvarh, 104],\n        // Byte 4\n        [\"ERPp1DSM\", TYPE_U24, 0, FMT_ld_kvarh, 107],\n\n        [\"DATEERNp1\", TYPE_DMYhms, 0, FMT_UNDEF, 110],\n        [\"ERNp1P\", TYPE_U24, 0, FMT_ld_kvarh, 116],\n        [\"ERNp1PM\", TYPE_U24, 0, FMT_ld_kvarh, 119],\n        [\"ERNp1HCE\", TYPE_U24, 0, FMT_ld_kvarh, 122],\n        [\"ERNp1HCH\", TYPE_U24, 0, FMT_ld_kvarh, 125],\n        [\"ERNp1HH\", TYPE_U24, 0, FMT_ld_kvarh, 128],\n        [\"ERNp1HCD\", TYPE_U24, 0, FMT_ld_kvarh, 131],\n        // Byte 5\n        [\"ERNp1HD\", TYPE_U24, 0, FMT_ld_kvarh, 134],\n        [\"ERNp1JA\", TYPE_U24, 0, FMT_ld_kvarh, 137],\n        [\"ERNp1HPE\", TYPE_U24, 0, FMT_ld_kvarh, 140],\n        [\"ERNp1HPH\", TYPE_U24, 0, FMT_ld_kvarh, 143],\n        [\"ERNp1HPD\", TYPE_U24, 0, FMT_ld_kvarh, 146],\n        [\"ERNp1SCM\", TYPE_U24, 0, FMT_ld_kvarh, 149],\n        [\"ERNp1HM\", TYPE_U24, 0, FMT_ld_kvarh, 152],\n        [\"ERNp1DSM\", TYPE_U24, 0, FMT_ld_kvarh, 155]\n        // Byte 6\n    ];\n\n\n    // ClusterID: 0x0054, Attribute ID : 0xii00\n    //-----------------------------------------\n    const CBE = [\n        // Byte 0\n        [\"ADIR1\", TYPE_U16, 0, FMT_03d],\n        [\"ADIR2\", TYPE_U16, 0, FMT_03d],\n        [\"ADIR3\", TYPE_U16, 0, FMT_03d],\n        [\"ADCO\", TYPE_CSTRING, 0, FMT_s],\n        [\"OPTARIF\", TYPE_CSTRING, 0, FMT_s],\n        [\"ISOUSC\", TYPE_U8, 0, FMT_02d],\n        [\"BASE\", TYPE_U32, 0, FMT_09ld],\n        [\"HCHC\", TYPE_U32, 0, FMT_09ld],\n        // Byte 1\n        [\"HCHP\", TYPE_U32, 0, FMT_09ld],\n        [\"EJPHN\", TYPE_U32, 0, FMT_09ld],\n        [\"EJPHPM\", TYPE_U32, 0, FMT_09ld],\n        [\"BBRHCJB\", TYPE_U32, 0, FMT_09ld],\n        [\"BBRHPJB\", TYPE_U32, 0, FMT_09ld],\n        [\"BBRHCJW\", TYPE_U32, 0, FMT_09ld],\n        [\"BBRHPJW\", TYPE_U32, 0, FMT_09ld],\n        [\"BBRHCJR\", TYPE_U32, 0, FMT_09ld],\n        // Byte 2\n        [\"BBRHPJR\", TYPE_U32, 0, FMT_09ld],\n        [\"PEJP\", TYPE_U8, 0, FMT_02d],\n        [\"GAZ\", TYPE_U32, 0, FMT_07ld],\n        [\"AUTRE\", TYPE_U32, 0, FMT_07ld],\n        [\"PTEC\", TYPE_CSTRING, 0, FMT_s],\n        [\"DEMAIN\", TYPE_CSTRING, 0, FMT_s],\n        [\"IINST\", TYPE_U16, 0, FMT_03d],\n        [\"IINST1\", TYPE_U16, 0, FMT_03d],\n        // Byte 3\n        [\"IINST2\", TYPE_U16, 0, FMT_03d],\n        [\"IINST3\", TYPE_U16, 0, FMT_03d],\n        [\"ADPS\", TYPE_U16, 0, FMT_03d],\n        [\"IMAX\", TYPE_U16, 0, FMT_03d],\n        [\"IMAX1\", TYPE_U16, 0, FMT_03d],\n        [\"IMAX2\", TYPE_U16, 0, FMT_03d],\n        [\"IMAX3\", TYPE_U16, 0, FMT_03d],\n        [\"PMAX\", TYPE_U32, 0, FMT_05ld],\n        // Byte 4\n        [\"PAPP\", TYPE_U32, 0, FMT_05ld],\n        [\"HHPHC\", TYPE_CHAR, 0, FMT_c],\n        [\"MOTDETAT\", TYPE_CSTRING, 0, FMT_s],\n        [\"PPOT\", TYPE_U8, 0, FMT_02X]\n    ];\n\n\n    // ClusterID: 0x0055, Attribute ID : 0xii00\n    //-----------------------------------------\n    const CJE = [\n        // Byte 0\n        [\"JAUNE\", TYPE_hmDM, 0, FMT_UNDEF],\t\t// [hh:mn:jj:mm]:pt:dp:abcde:kp\n        [\"JAUNE\", TYPE_CSTRING, 0, FMT_s],\t// pt\n        [\"JAUNE\", TYPE_CSTRING, 0, FMT_s],  // dp\n        [\"JAUNE\", TYPE_U24, 0, FMT_05ld],\t// abcde\n        [\"JAUNE\", TYPE_U8, 0, FMT_02d],\t\t// kp\n        [\"ENERG\", TYPE_6U24, 0, FMT_06ld],\t\t// 111111:222222:...:666666\n        [\"ENERG\", TYPE_U24, 0, FMT_06ld],\t\t// 222222\n        [\"ENERG\", TYPE_U24, 0, FMT_06ld],\t\t// 333333\n        // Byte 1\n        [\"ENERG\", TYPE_U24, 0, FMT_06ld],\t\t// 444444\n        [\"ENERG\", TYPE_U24, 0, FMT_06ld],\t\t// 555555\n        [\"ENERG\", TYPE_U24, 0, FMT_06ld],\t\t// 666666\n        [\"PERCC\", TYPE_DMh, 0, FMT_UNDEF],\t\t// jj:mm:hh[:cg]\n        [\"PERCC\", TYPE_U8, 0, FMT_02d],\t\t// cg\n        [\"PMAXC\", TYPE_4U24, 0, FMT_05ld],\t\t// 11111:22222:...:44444\n        [\"PMAXC\", TYPE_U24, 0, FMT_05ld],\t\t// 22222\n        [\"PMAXC\", TYPE_U24, 0, FMT_05ld],\t\t// 33333\n        // Byte 2\n        [\"PMAXC\", TYPE_U24, 0, FMT_05ld],\t\t// 44444\n        [\"TDEPA\", TYPE_4U24, 0, FMT_05ld],\t\t// 11111:22222:...:44444\n        [\"TDEPA\", TYPE_U24, 0, FMT_05ld],\t\t// 22222\n        [\"TDEPA\", TYPE_U24, 0, FMT_05ld],\t\t// 33333\n        [\"TDEPA\", TYPE_U24, 0, FMT_05ld],\t\t// 44444\n        [\"PERCP\", TYPE_DMh, 0, FMT_UNDEF],\t\t// [jj:mm:hh]:cg\n        [\"PERCP\", TYPE_U8, 0, FMT_02d],\t\t// cg\n        [\"PMAXP\", TYPE_4U24, 0, FMT_05ld],\t\t// 11111:22222:...:44444\n        // Byte 3\n        [\"PMAXP\", TYPE_U24, 0, FMT_05ld],\t\t// 22222\n        [\"PMAXP\", TYPE_U24, 0, FMT_05ld],\t\t// 33333\n        [\"PMAXP\", TYPE_U24, 0, FMT_05ld],\t\t// 44444\n        [\"PSOUSC\", TYPE_4U24, 0, FMT_05ld],\t\t// 11111:22222:...:44444\n        [\"PSOUSC\", TYPE_U24, 0, FMT_05ld],\t\t// 22222\n        [\"PSOUSC\", TYPE_U24, 0, FMT_05ld],\t\t// 33333\n        [\"PSOUSC\", TYPE_U24, 0, FMT_05ld],\t\t// 44444\n        [\"PSOUSP\", TYPE_4U24, 0, FMT_05ld],\t\t// 11111:22222:...:44444\n        // Byte 4\n        [\"PSOUSP\", TYPE_U24, 0, FMT_05ld],\t\t// 22222\n        [\"PSOUSP\", TYPE_U24, 0, FMT_05ld],\t\t// 33333\n        [\"PSOUSP\", TYPE_U24, 0, FMT_05ld],\t\t// 44444\n        [\"FCOU\", TYPE_hm, 0, FMT_UNDEF],\t\t// [hh:mn]:dd\n        [\"FCOU\", TYPE_U8, 0, FMT_02d]\t\t// dd\n    ];\n\n\n    // ClusterID: 0x0056, Attribute ID : 0xii00\n    //-----------------------------------------\n    const STD = [\n        // Byte 0\n        [\"ADSC\", TYPE_CSTRING, 0, FMT_s],\n        [\"VTIC\", TYPE_U8, 0, FMT_02d],\n        [\"DATE\", TYPE_SDMYhms, 0, FMT_UNDEF],\n        [\"NGTF\", TYPE_E_STD_CONTRAT, 0, FMT_s],\n        [\"LTARF\", TYPE_E_STD_PT, 0, FMT_s],\n        [\"EAST\", TYPE_U32, 0, FMT_09ld],\n        [\"EASF01\", TYPE_U32, 0, FMT_09ld],\n        [\"EASF02\", TYPE_U32, 0, FMT_09ld],\n        // Byte 1\n        [\"EASF03\", TYPE_U32, 0, FMT_09ld],\n        [\"EASF04\", TYPE_U32, 0, FMT_09ld],\n        [\"EASF05\", TYPE_U32, 0, FMT_09ld],\n        [\"EASF06\", TYPE_U32, 0, FMT_09ld],\n        [\"EASF07\", TYPE_U32, 0, FMT_09ld],\n        [\"EASF08\", TYPE_U32, 0, FMT_09ld],\n        [\"EASF09\", TYPE_U32, 0, FMT_09ld],\n        [\"EASF10\", TYPE_U32, 0, FMT_09ld],\n        // Byte 2\n        [\"EASD01\", TYPE_U32, 0, FMT_09ld],\n        [\"EASD02\", TYPE_U32, 0, FMT_09ld],\n        [\"EASD03\", TYPE_U32, 0, FMT_09ld],\n        [\"EASD04\", TYPE_U32, 0, FMT_09ld],\n        [\"EAIT\", TYPE_U32, 0, FMT_09ld],\n        [\"ERQ1\", TYPE_U32, 0, FMT_09ld],\n        [\"ERQ2\", TYPE_U32, 0, FMT_09ld],\n        [\"ERQ3\", TYPE_U32, 0, FMT_09ld],\n        // Byte 3\n        [\"ERQ4\", TYPE_U32, 0, FMT_09ld],\n        [\"IRMS1\", TYPE_U16, 0, FMT_03d],\n        [\"IRMS2\", TYPE_U16, 0, FMT_03d],\n        [\"IRMS3\", TYPE_U16, 0, FMT_03d],\n        [\"URMS1\", TYPE_U16, 0, FMT_03d],\n        [\"URMS2\", TYPE_U16, 0, FMT_03d],\n        [\"URMS3\", TYPE_U16, 0, FMT_03d],\n        [\"PREF\", TYPE_U8, 0, FMT_02d],\n        // Byte 4\n        [\"PCOUP\", TYPE_U8, 0, FMT_02d],\n        [\"SINSTS\", TYPE_U24, 0, FMT_05ld],\n        [\"SINSTS1\", TYPE_U24, 0, FMT_05ld],\n        [\"SINSTS2\", TYPE_U24, 0, FMT_05ld],\n        [\"SINSTS3\", TYPE_U24, 0, FMT_05ld],\n        [\"SMAXSN\", TYPE_SDMYhmsU24, 0, FMT_05ld],\n        [\"SMAXSN1\", TYPE_SDMYhmsU24, 0, FMT_05ld],\n        [\"SMAXSN2\", TYPE_SDMYhmsU24, 0, FMT_05ld],\n        // Byte 5\n        [\"SMAXSN3\", TYPE_SDMYhmsU24, 0, FMT_05ld],\n        [\"SMAXSN?1\", TYPE_SDMYhmsU24, 0, FMT_05ld],\n        [\"SMAXSN1?1\", TYPE_SDMYhmsU24, 0, FMT_05ld],\n        [\"SMAXSN2?1\", TYPE_SDMYhmsU24, 0, FMT_05ld],\n        [\"SMAXSN3?1\", TYPE_SDMYhmsU24, 0, FMT_05ld],\n        [\"SINSTI\", TYPE_U24, 0, FMT_05ld],\n        [\"SMAXIN\", TYPE_SDMYhmsU24, 0, FMT_05ld],\n        [\"SMAXIN-1\", TYPE_SDMYhmsU24, 0, FMT_05ld],\n        // Byte 6\n        [\"CCASN\", TYPE_SDMYhmsU24, 0, FMT_05ld],\n        [\"CCASN?1\", TYPE_SDMYhmsU24, 0, FMT_05ld],\n        [\"CCAIN\", TYPE_SDMYhmsU24, 0, FMT_05ld],\n        [\"CCAIN?1\", TYPE_SDMYhmsU24, 0, FMT_05ld],\n        [\"UMOY1\", TYPE_SDMYhmsU16, 0, FMT_03d],\n        [\"UMOY2\", TYPE_SDMYhmsU16, 0, FMT_03d],\n        [\"UMOY3\", TYPE_SDMYhmsU16, 0, FMT_03d],\n        [\"STGE\", TYPE_BF32xbe, 0, FMT_UNDEF],\n        // Byte 7\n        [\"DPM1\", TYPE_SDMYhmsU8, 0, FMT_02d],\n        [\"FPM1\", TYPE_SDMYhmsU8, 0, FMT_02d],\n        [\"DPM2\", TYPE_SDMYhmsU8, 0, FMT_02d],\n        [\"FPM2\", TYPE_SDMYhmsU8, 0, FMT_02d],\n        [\"DPM3\", TYPE_SDMYhmsU8, 0, FMT_02d],\n        [\"FPM3\", TYPE_SDMYhmsU8, 0, FMT_02d],\n        [\"MSG1\", TYPE_CSTRING, 0, FMT_s],\n        [\"MSG2\", TYPE_CSTRING, 0, FMT_s],\n        // Byte 8\n        [\"PRM\", TYPE_CSTRING, 0, FMT_s],\n        [\"RELAIS\", TYPE_BF8d, 0, FMT_03d],\n        [\"NTARF\", TYPE_U8, 0, FMT_02d],\n        [\"NJOURF\", TYPE_U8, 0, FMT_02d],\n        [\"NJOURF+1\", TYPE_U8, 0, FMT_02d],\n        [\"PJOURF+1\", TYPE_11hhmmSSSS, 0, FMT_UNDEF],\n        [\"PPOINTE\", TYPE_11hhmmSSSS, 0, FMT_UNDEF]\n    ];\n\n    // ClusterID: 0x0057, Attribute ID : 0xii00\n    //-----------------------------------------\n    const PMEPMI = [\n        //Byte 0\n        [\"TRAME\", TYPE_E_DIV, 0, FMT_s], /* Uniquement Palier 2013 */\n        [\"ADS\", TYPE_HEXSTRING, 0, FMT_UNDEF], /* Uniquement Palier 2013 */\n        [\"MESURES1\", TYPE_E_CONTRAT, 0, FMT_s],\n        [\"DATE\", TYPE_DMYhms, 0, FMT_UNDEF],\n        [\"EA_s\", TYPE_U24, 0, FMT_ld_Wh],\n        [\"ER+_s\", TYPE_U24, 0, FMT_ld_varh],\n        [\"ER-_s\", TYPE_U24, 0, FMT_ld_varh],\n        [\"EAPP_s\", TYPE_U24, 0, FMT_ld_VAh],\n        //Byte 1\n        [\"EA_i\", TYPE_U24, 0, FMT_ld_Wh],\n        [\"ER+_i\", TYPE_U24, 0, FMT_ld_varh],\n        [\"ER-_i\", TYPE_U24, 0, FMT_ld_varh],\n        [\"EAPP_i\", TYPE_U24, 0, FMT_ld_VAh],\n        [\"PTCOUR1\", TYPE_E_PT, 0, FMT_s],\n        [\"TARIFDYN\", TYPE_E_DIV, 0, FMT_s],\n        [\"ETATDYN1\", TYPE_E_PT, 0, FMT_s],\n        [\"PREAVIS1\", TYPE_E_PT, 0, FMT_PREAVIS_PT],\n        //Byte 2\n        [\"TDYN1CD\", TYPE_tsDMYhms_E_PT, 0, FMT_UNDEF],\n        [\"TDYN1CF\", TYPE_tsDMYhms_E_PT, 0, FMT_UNDEF],\n        [\"TDYN1FD\", TYPE_tsDMYhms_E_PT, 0, FMT_UNDEF],\n        [\"TDYN1FF\", TYPE_tsDMYhms_E_PT, 0, FMT_UNDEF],\n        [\"MODE\", TYPE_E_DIV, 0, FMT_s],\n        [\"CONFIG\", TYPE_E_DIV, 0, FMT_s],\n        [\"DATEPA1\", TYPE_DMYhms, 0, FMT_UNDEF],\n        [\"PA1_s\", TYPE_U16, 0, FMT_d_kW],\n        // Byte 3\n        [\"PA1_i\", TYPE_U16, 0, FMT_d_kW],\n        [\"DATEPA2\", TYPE_tsDMYhms, 0, FMT_UNDEF],\n        [\"PA2_s\", TYPE_U16, 0, FMT_d_kW],\n        [\"PA2_i\", TYPE_U16, 0, FMT_d_kW],\n        [\"DATEPA3\", TYPE_tsDMYhms, 0, FMT_UNDEF],\n        [\"PA3_s\", TYPE_U16, 0, FMT_d_kW],\n        [\"PA3_i\", TYPE_U16, 0, FMT_d_kW],\n        [\"DATEPA4\", TYPE_tsDMYhms, 0, FMT_UNDEF],\n        //Byte 4\n        [\"PA4_s\", TYPE_U16, 0, FMT_d_kW],\n        [\"PA4_i\", TYPE_U16, 0, FMT_d_kW],\n        [\"DATEPA5\", TYPE_tsDMYhms, 0, FMT_UNDEF],\n        [\"PA5_s\", TYPE_U16, 0, FMT_d_kW],\n        [\"PA5_i\", TYPE_U16, 0, FMT_d_kW],\n        [\"DATEPA6\", TYPE_tsDMYhms, 0, FMT_UNDEF],\n        [\"PA6_s\", TYPE_U16, 0, FMT_d_kW],\n        [\"PA6_i\", TYPE_U16, 0, FMT_d_kW],\n        //Byte 5\n        [\"DebP\", TYPE_tsDMYhms, 0, FMT_UNDEF],\n        [\"EAP_s\", TYPE_U24, 0, FMT_d_kWh],\n        [\"EAP_i\", TYPE_U24, 0, FMT_d_kWh],\n        [\"ER+P_s\", TYPE_U24, 0, FMT_d_kvarh],\n        [\"ER-P_s\", TYPE_U24, 0, FMT_d_kvarh],\n        [\"ER+P_i\", TYPE_U24, 0, FMT_d_kvarh],\n        [\"ER-P_i\", TYPE_U24, 0, FMT_d_kvarh],\n        [\"DebP-1\", TYPE_tsDMYhms, 0, FMT_UNDEF],\n        //Byte 6\n        [\"FinP-1\", TYPE_tsDMYhms, 0, FMT_UNDEF],\n        [\"EaP-1_s\", TYPE_U24, 0, FMT_d_kWh],\n        [\"EaP-1_i\", TYPE_U24, 0, FMT_d_kWh],\n        [\"ER+P-1_s\", TYPE_U24, 0, FMT_d_kvarh],\n        [\"ER-P-1_s\", TYPE_U24, 0, FMT_d_kvarh],\n        [\"ER+P-1_i\", TYPE_U24, 0, FMT_d_kvarh],\n        [\"ER-P-1_i\", TYPE_U24, 0, FMT_d_kvarh],\n        [\"PS\", TYPE_U24_E_DIV, 0, FMT_UNDEF],\n        //Byte 7\n        [\"PREAVIS\", TYPE_E_DIV, 0, FMT_s],\n        [\"PA1MN\", TYPE_U16, 0, FMT_d_kW],\n        [\"PMAX_s\", TYPE_U24_E_DIV, 0, FMT_UNDEF],\n        [\"PMAX_i\", TYPE_U24_E_DIV, 0, FMT_UNDEF],\n        [\"TGPHI_s\", TYPE_FLOAT, 0, FMT_05_2f],\n        [\"TGPHI_i\", TYPE_FLOAT, 0, FMT_05_2f],\n        [\"MESURES2\", TYPE_E_CONTRAT, 0, FMT_s],\n        [\"PTCOUR2\", TYPE_E_PT, 0, FMT_s],\n        //Byte 8\n        [\"ETATDYN2\", TYPE_E_PT, 0, FMT_s],\n        [\"PREAVIS2\", TYPE_E_PT, 0, FMT_PREAVIS_PT],\n        [\"TDYN2CD\", TYPE_tsDMYhms_E_PT, 0, FMT_UNDEF],\n        [\"TDYN2CF\", TYPE_tsDMYhms_E_PT, 0, FMT_UNDEF],\n        [\"TDYN2FD\", TYPE_tsDMYhms_E_PT, 0, FMT_UNDEF],\n        [\"TDYN2FF\", TYPE_tsDMYhms_E_PT, 0, FMT_UNDEF],\n        [\"DebP_2\", TYPE_tsDMYhms, 0, FMT_UNDEF],\n        [\"EaP_s2\", TYPE_U24, 0, FMT_d_kWh],\n        //Byte 9\n        [\"DebP-1_2\", TYPE_tsDMYhms, 0, FMT_UNDEF],\n        [\"FinP-1_2\", TYPE_tsDMYhms, 0, FMT_UNDEF],\n        [\"EaP-1_s2\", TYPE_U24, 0, FMT_d_kWh],\n        [\"_DDMES1_\", TYPE_U24, 0, FMT_d_s]\n    ];\n\n\n    // ============================================\n    // ============================================\n    // DECODING PART\n    // ============================================\n    // ============================================\n\n    // Init object container for decoded fields \n    let data = {}\n\n    // Select PROFIL according to cluster/attribute\n    let profil\n    if (ClusterID == 0x0053) {\n        // if (attributeID && 0x00FF == 0) {\n        //     profil = ICE_General;\n        //     data[\"_TICFrameType\"] = \"ICE Generale\";\n        // } else if (attributeID && 0x00FF == 1) {\n        //     profil = ICE_p;\n        //     data[\"_TICFrameType\"] = \"ICE Periode P\";\n        // } else if (attributeID && 0x0001 == 2) {\n        //     profil = ICE_p1;\n        //     data[\"_TICFrameType\"] = \"ICE Periode P moins 1\";\n        // } else {\n        //     return data;\n        // }\n    } else if (ClusterID == 0x0054) {\n        profil = CBE;\n        data[\"_TICFrameType\"] = \"CBE/Historique\";\n    } else if (ClusterID == 0x0055) {\n        profil = CJE;\n        data[\"_TICFrameType\"] = \"CJE\";\n    } else if (ClusterID == 0x0056) {\n        profil = STD;\n        data[\"_TICFrameType\"] = \"Standard\";\n    } else if (ClusterID == 0x0057) {\n        profil = PMEPMI;\n        data[\"_TICFrameType\"] = \"PMEPMI\";\n    } else {\n        return data;\n        data[\"_TICFrameType\"] = \"Unexpected\";\n    }\n\n    // Start Decoding descriptor\n    let { DescSize, Indexes } = TICParseDescToIndexes(BytesAfterSize);\n\n    var DescBytes = BytesAfterSize.slice(0, DescSize);\n    var x = {}\n    if ((DescBytes[0] & 0x80) == 0x80) {\n        x.Obsolete = true;\n    }\n    x.Bytes = BytesToHexStr(DescBytes);\n    x.Indexes = Indexes;\n    data[\"_Descriptor\"] = x;\n\n    // Start effective fields decodings\n    var bytesIndex = DescSize;\n    for (var j = 0; j < Indexes.length; j++) {\n        let fieldIndex = Indexes[j];\n        let d = profil[fieldIndex][1](BytesAfterSize, bytesIndex);\n        data[profil[fieldIndex][0]] = profil[fieldIndex][3](d.x);\n        bytesIndex = d.i;\n    }\n    return data;\n}\n\n\n/* \n * ===============================================================================\n * Main decoding function\n * ===============================================================================\n */\nfunction Decoder(bytes, port) {\n    // Decode an uplink message from a buffer\n    // (array) of bytes to an object of fields.\n    var decoded = {};\n    decoded.lora = {};\n\n    decoded.lora.port = port;\n\n    // Get raw payload\n    var bytes_len_ = bytes.length;\n    var temp_hex_str = \"\"\n\n    decoded.lora.payload = \"\";\n\n    for (var j = 0; j < bytes_len_; j++) {\n        temp_hex_str = bytes[j].toString(16).toUpperCase();\n        if (temp_hex_str.length == 1) {\n            temp_hex_str = \"0\" + temp_hex_str;\n        }\n        decoded.lora.payload += temp_hex_str;\n        var date = new Date();\n        decoded.lora.date = date.toISOString();\n    }\n\n    if (port === 125) {\n        //batch\n        let batch = !(bytes[0] & 0x01);\n\n        //trame standard\n        if (batch === false) {\n            decoded.zclheader = {};\n            decoded.zclheader.report = \"standard\";\n            let attributID = -1;\n            let cmdID = -1;\n            let clusterdID = -1;\n            //endpoint\n            decoded.zclheader.endpoint = ((bytes[0] & 0xE0) >> 5) | ((bytes[0] & 0x06) << 2);\n            //command ID\n            cmdID = bytes[1]; decoded.zclheader.cmdID = decimalToHex(cmdID, 2);\n            //Cluster ID\n            clusterdID = bytes[2] * 256 + bytes[3]; decoded.zclheader.clusterdID = decimalToHex(clusterdID, 4);\n\n            // decode report and read atrtribut response\n            if ((cmdID === 0x0a) || (cmdID === 0x8a) || (cmdID === 0x01)) {\n                decoded.data = {};\n                //Attribut ID \n                attributID = bytes[4] * 256 + bytes[5]; decoded.zclheader.attributID = decimalToHex(attributID, 4);\n\n                if (cmdID === 0x8a) decoded.zclheader.alarm = 1;\n                //data index start\n                let index\n                let state\n                if ((cmdID === 0x0a) || (cmdID === 0x8a)) index = 7;\n                if (cmdID === 0x01) { index = 8; decoded.zclheader.status = bytes[6]; }\n\n                //temperature\n                if ((clusterdID === 0x0402) && (attributID === 0x0000)) decoded.data.temperature = (UintToInt(bytes[index] * 256 + bytes[index + 1], 2)) / 100;\n                //humidity\n                if ((clusterdID === 0x0405) && (attributID === 0x0000)) decoded.data.humidity = (bytes[index] * 256 + bytes[index + 1]) / 100;\n                //binary input counter\n                if ((clusterdID === 0x000f) && (attributID === 0x0402)) decoded.data.counter = (bytes[index] * 256 * 256 * 256 + bytes[index + 1] * 256 * 256 + bytes[index + 2] * 256 + bytes[index + 3]);\n                // binary input present value\n                if ((clusterdID === 0x000f) && (attributID === 0x0055)) decoded.data.pin_state = !(!bytes[index]);\n                //multistate output\n                if ((clusterdID === 0x0013) && (attributID === 0x0055)) decoded.data.value = bytes[index];\n                // on/off present value\n                if ((clusterdID === 0x0006) && (attributID === 0x0000)) { state = bytes[index]; if (state === 1) decoded.data.state = \"ON\"; else decoded.data.state = \"OFF\"; }\n                //differential pressure\n                if ((clusterdID === 0x8008) && (attributID === 0x0000)) decoded.data.differential_pressure = bytes[index] * 256 + bytes[index + 1];\n                // multibinary input present value\n                if ((clusterdID === 0x8005) && (attributID === 0x0000)) {\n                    decoded.data.pin_state_1 = ((bytes[index + 1] & 0x01) === 0x01);\n                    decoded.data.pin_state_2 = ((bytes[index + 1] & 0x02) === 0x02);\n                    decoded.data.pin_state_3 = ((bytes[index + 1] & 0x04) === 0x04);\n                    decoded.data.pin_state_4 = ((bytes[index + 1] & 0x08) === 0x08);\n                    decoded.data.pin_state_5 = ((bytes[index + 1] & 0x10) === 0x10);\n                    decoded.data.pin_state_6 = ((bytes[index + 1] & 0x20) === 0x20);\n                    decoded.data.pin_state_7 = ((bytes[index + 1] & 0x40) === 0x40);\n                    decoded.data.pin_state_8 = ((bytes[index + 1] & 0x80) === 0x80);\n                    decoded.data.pin_state_9 = ((bytes[index] & 0x01) === 0x01);\n                    decoded.data.pin_state_10 = ((bytes[index] & 0x02) === 0x02);\n                }\n                //analog input\n                if ((clusterdID === 0x000c) && (attributID === 0x0055)) decoded.data.analog = Bytes2Float32(bytes[index] * 256 * 256 * 256 + bytes[index + 1] * 256 * 256 + bytes[index + 2] * 256 + bytes[index + 3]);\n\n                //modbus \n                if ((clusterdID === 0x8007) && (attributID === 0x0001)) {\n                    decoded.data.payload = \"\";\n                    decoded.data.modbus_payload = \"\";\n                    decoded.data.size = bytes[index];\n                    decoded.data.modbus_float = 0; // 0: pas de décodage float 1: décodage float 2: décodage float 2word inversé\n                    for (var j = 0; j < decoded.data.size; j++) {\n\n                        temp_hex_str = bytes[index + j + 1].toString(16).toUpperCase();\n                        if (temp_hex_str.length == 1) {\n                            temp_hex_str = \"0\" + temp_hex_str;\n                        }\n                        decoded.data.payload += temp_hex_str;\n\n                        if (j == 0) {\n                            decoded.data.modbus_address = bytes[index + j + 1];\n                        }\n                        else if (j == 1) {\n                            decoded.data.modbus_commandID = bytes[index + j + 1];\n                        }\n                        else if (j == 2) {\n                            decoded.data.modbus_size = bytes[index + j + 1];\n                        }\n                        else {\n                            decoded.data.modbus_payload += temp_hex_str;\n                            if (decoded.data.modbus_float == 1) { // big endian\n                                if (j == 3) decoded.data.fregister_00 = Bytes2Float32(bytes[index + j + 1] * 256 * 256 * 256 + bytes[index + j + 1 + 1] * 256 * 256 + bytes[index + j + 1 + 2] * 256 + bytes[index + j + 1 + 3]);\n                                if (j == 7) decoded.data.fregister_01 = Bytes2Float32(bytes[index + j + 1] * 256 * 256 * 256 + bytes[index + j + 1 + 1] * 256 * 256 + bytes[index + j + 1 + 2] * 256 + bytes[index + j + 1 + 3]);\n                                if (j == 11) decoded.data.fregister_02 = Bytes2Float32(bytes[index + j + 1] * 256 * 256 * 256 + bytes[index + j + 1 + 1] * 256 * 256 + bytes[index + j + 1 + 2] * 256 + bytes[index + j + 1 + 3]);\n                                if (j == 15) decoded.data.fregister_03 = Bytes2Float32(bytes[index + j + 1] * 256 * 256 * 256 + bytes[index + j + 1 + 1] * 256 * 256 + bytes[index + j + 1 + 2] * 256 + bytes[index + j + 1 + 3]);\n                                if (j == 19) decoded.data.fregister_04 = Bytes2Float32(bytes[index + j + 1] * 256 * 256 * 256 + bytes[index + j + 1 + 1] * 256 * 256 + bytes[index + j + 1 + 2] * 256 + bytes[index + j + 1 + 3]);\n                                if (j == 23) decoded.data.fregister_05 = Bytes2Float32(bytes[index + j + 1] * 256 * 256 * 256 + bytes[index + j + 1 + 1] * 256 * 256 + bytes[index + j + 1 + 2] * 256 + bytes[index + j + 1 + 3]);\n                                if (j == 27) decoded.data.fregister_06 = Bytes2Float32(bytes[index + j + 1] * 256 * 256 * 256 + bytes[index + j + 1 + 1] * 256 * 256 + bytes[index + j + 1 + 2] * 256 + bytes[index + j + 1 + 3]);\n                                if (j == 31) decoded.data.fregister_07 = Bytes2Float32(bytes[index + j + 1] * 256 * 256 * 256 + bytes[index + j + 1 + 1] * 256 * 256 + bytes[index + j + 1 + 2] * 256 + bytes[index + j + 1 + 3]);\n                                if (j == 35) decoded.data.fregister_08 = Bytes2Float32(bytes[index + j + 1] * 256 * 256 * 256 + bytes[index + j + 1 + 1] * 256 * 256 + bytes[index + j + 1 + 2] * 256 + bytes[index + j + 1 + 3]);\n                                if (j == 35) decoded.data.fregister_09 = Bytes2Float32(bytes[index + j + 1] * 256 * 256 * 256 + bytes[index + j + 1 + 1] * 256 * 256 + bytes[index + j + 1 + 2] * 256 + bytes[index + j + 1 + 3]);\n                            }\n                            if (decoded.data.modbus_float == 2) { // float little endian 2 word\n                                if (j == 3) decoded.data.fregister_00 = Bytes2Float32(bytes[index + j + 1] * 256 + bytes[index + j + 1 + 1] + bytes[index + j + 1 + 2] * 256 * 256 * 256 + bytes[index + j + 1 + 3] * 256 * 256);\n                                if (j == 7) decoded.data.fregister_01 = Bytes2Float32(bytes[index + j + 1] * 256 + bytes[index + j + 1 + 1] + bytes[index + j + 1 + 2] * 256 * 256 * 256 + bytes[index + j + 1 + 3] * 256 * 256);\n                                if (j == 11) decoded.data.fregister_02 = Bytes2Float32(bytes[index + j + 1] * 256 + bytes[index + j + 1 + 1] + bytes[index + j + 1 + 2] * 256 * 256 * 256 + bytes[index + j + 1 + 3] * 256 * 256);\n                                if (j == 15) decoded.data.fregister_03 = Bytes2Float32(bytes[index + j + 1] * 256 + bytes[index + j + 1 + 1] + bytes[index + j + 1 + 2] * 256 * 256 * 256 + bytes[index + j + 1 + 3] * 256 * 256);\n                                if (j == 19) decoded.data.fregister_04 = Bytes2Float32(bytes[index + j + 1] * 256 + bytes[index + j + 1 + 1] + bytes[index + j + 1 + 2] * 256 * 256 * 256 + bytes[index + j + 1 + 3] * 256 * 256);\n                                if (j == 23) decoded.data.fregister_05 = Bytes2Float32(bytes[index + j + 1] * 256 + bytes[index + j + 1 + 1] + bytes[index + j + 1 + 2] * 256 * 256 * 256 + bytes[index + j + 1 + 3] * 256 * 256);\n                                if (j == 27) decoded.data.fregister_06 = Bytes2Float32(bytes[index + j + 1] * 256 + bytes[index + j + 1 + 1] + bytes[index + j + 1 + 2] * 256 * 256 * 256 + bytes[index + j + 1 + 3] * 256 * 256);\n                                if (j == 31) decoded.data.fregister_07 = Bytes2Float32(bytes[index + j + 1] * 256 + bytes[index + j + 1 + 1] + bytes[index + j + 1 + 2] * 256 * 256 * 256 + bytes[index + j + 1 + 3] * 256 * 256);\n                                if (j == 35) decoded.data.fregister_08 = Bytes2Float32(bytes[index + j + 1] * 256 + bytes[index + j + 1 + 1] + bytes[index + j + 1 + 2] * 256 * 256 * 256 + bytes[index + j + 1 + 3] * 256 * 256);\n                                if (j == 35) decoded.data.fregister_09 = Bytes2Float32(bytes[index + j + 1] * 256 + bytes[index + j + 1 + 1] + bytes[index + j + 1 + 2] * 256 * 256 * 256 + bytes[index + j + 1 + 3] * 256 * 256);\n                            }\n\n                        }\n\n                    }\n                }\n\n                //multimodbus \n                if ((clusterdID === 0x8009) && (attributID === 0x0000)) {\n                    decoded.data.payloads = \"\";\n                    decoded.data.size = bytes[index];\n                    decoded.data.multimodbus_frame_series_sent = bytes[index + 1];\n                    decoded.data.multimodbus_frame_number_in_serie = (bytes[index + 2] & 0xE0) >> 5;\n                    decoded.data.multimodbus_last_frame_of_serie = (bytes[index + 2] & 0x1C) >> 2;\n                    decoded.data.multimodbus_EP9 = ((bytes[index + 2] & 0x01) === 0x01);\n                    decoded.data.multimodbus_EP8 = ((bytes[index + 2] & 0x02) === 0x02);\n                    decoded.data.multimodbus_EP7 = ((bytes[index + 3] & 0x80) === 0x80);\n                    decoded.data.multimodbus_EP6 = ((bytes[index + 3] & 0x40) === 0x40);\n                    decoded.data.multimodbus_EP5 = ((bytes[index + 3] & 0x20) === 0x20);\n                    decoded.data.multimodbus_EP4 = ((bytes[index + 3] & 0x10) === 0x10);\n                    decoded.data.multimodbus_EP3 = ((bytes[index + 3] & 0x08) === 0x08);\n                    decoded.data.multimodbus_EP2 = ((bytes[index + 3] & 0x04) === 0x04);\n                    decoded.data.multimodbus_EP1 = ((bytes[index + 3] & 0x02) === 0x02);\n                    decoded.data.multimodbus_EP0 = ((bytes[index + 3] & 0x01) === 0x01);\n                    let index2 = index + 4;\n                    let without_header = 0;\n\n                    if (decoded.data.multimodbus_EP0 === true) {\n                        if (without_header === 0) {\n                            decoded.data.multimodbus_EP0_slaveID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP0_fnctID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP0_datasize = bytes[index2];\n                            index2 = index2 + 1;\n                        }\n                        decoded.data.multimodbus_EP0_payload = \"\"\n                        if (bytes[index2] === undefined) return decoded;\n                        for (var j = 0; j < decoded.data.multimodbus_EP0_datasize; j++) {\n                            temp_hex_str = bytes[index2 + j].toString(16).toUpperCase();\n                            if (temp_hex_str.length == 1) {\n                                temp_hex_str = \"0\" + temp_hex_str;\n                            }\n                            decoded.data.multimodbus_EP0_payload += temp_hex_str;\n                        }\n                        index2 = index2 + decoded.data.multimodbus_EP0_datasize;\n                    }\n\n                    if (decoded.data.multimodbus_EP1 === true) {\n                        if (without_header === 0) {\n                            decoded.data.multimodbus_EP1_slaveID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP1_fnctID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP1_datasize = bytes[index2];\n                            index2 = index2 + 1;\n                        }\n                        decoded.data.multimodbus_EP1_payload = \"\"\n                        if (bytes[index2] === undefined) return decoded;\n                        for (var j = 0; j < decoded.data.multimodbus_EP1_datasize; j++) {\n                            temp_hex_str = bytes[index2 + j].toString(16).toUpperCase();\n                            if (temp_hex_str.length == 1) {\n                                temp_hex_str = \"0\" + temp_hex_str;\n                            }\n                            decoded.data.multimodbus_EP1_payload += temp_hex_str;\n                        }\n                        index2 = index2 + decoded.data.multimodbus_EP1_datasize;\n                    }\n                    if (decoded.data.multimodbus_EP2 === true) {\n                        if (without_header === 0) {\n                            decoded.data.multimodbus_EP2_slaveID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP2_fnctID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP2_datasize = bytes[index2];\n                            index2 = index2 + 1;\n                        }\n                        decoded.data.multimodbus_EP2_payload = \"\"\n                        if (bytes[index2] === undefined) return decoded;\n                        for (var j = 0; j < decoded.data.multimodbus_EP2_datasize; j++) {\n                            temp_hex_str = bytes[index2 + j].toString(16).toUpperCase();\n                            if (temp_hex_str.length == 1) {\n                                temp_hex_str = \"0\" + temp_hex_str;\n                            }\n                            decoded.data.multimodbus_EP2_payload += temp_hex_str;\n                        }\n                        index2 = index2 + decoded.data.multimodbus_EP2_datasize;\n                    }\n                    if (decoded.data.multimodbus_EP3 === true) {\n                        if (without_header === 0) {\n                            decoded.data.multimodbus_EP3_slaveID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP3_fnctID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP3_datasize = bytes[index2];\n                            index2 = index2 + 1;\n                        }\n                        decoded.data.multimodbus_EP3_payload = \"\"\n                        if (bytes[index2] === undefined) return decoded;\n                        for (var j = 0; j < decoded.data.multimodbus_EP3_datasize; j++) {\n                            temp_hex_str = bytes[index2 + j].toString(16).toUpperCase();\n                            if (temp_hex_str.length == 1) {\n                                temp_hex_str = \"0\" + temp_hex_str;\n                            }\n                            decoded.data.multimodbus_EP3_payload += temp_hex_str;\n                        }\n                        index2 = index2 + decoded.data.multimodbus_EP3_datasize;\n                    }\n                    if (decoded.data.multimodbus_EP4 === true) {\n                        if (without_header === 0) {\n                            decoded.data.multimodbus_EP4_slaveID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP4_fnctID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP4_datasize = bytes[index2];\n                            index2 = index2 + 1;\n                        }\n                        decoded.data.multimodbus_EP4_payload = \"\"\n                        if (bytes[index2] === undefined) return decoded;\n                        for (var j = 0; j < decoded.data.multimodbus_EP4_datasize; j++) {\n                            temp_hex_str = bytes[index2 + j].toString(16).toUpperCase();\n                            if (temp_hex_str.length == 1) {\n                                temp_hex_str = \"0\" + temp_hex_str;\n                            }\n                            decoded.data.multimodbus_EP4_payload += temp_hex_str;\n                        }\n                        index2 = index2 + decoded.data.multimodbus_EP4_datasize;\n                    }\n                    if (decoded.data.multimodbus_EP5 === true) {\n                        if (without_header === 0) {\n                            decoded.data.multimodbus_EP5_slaveID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP5_fnctID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP5_datasize = bytes[index2];\n                            index2 = index2 + 1;\n                        }\n                        decoded.data.multimodbus_EP5_payload = \"\"\n                        if (bytes[index2] === undefined) return decoded;\n                        for (var j = 0; j < decoded.data.multimodbus_EP5_datasize; j++) {\n                            temp_hex_str = bytes[index2 + j].toString(16).toUpperCase();\n                            if (temp_hex_str.length == 1) {\n                                temp_hex_str = \"0\" + temp_hex_str;\n                            }\n                            decoded.data.multimodbus_EP5_payload += temp_hex_str;\n                        }\n                        index2 = index2 + decoded.data.multimodbus_EP5_datasize;\n                    }\n                    if (decoded.data.multimodbus_EP6 === true) {\n                        if (without_header === 0) {\n                            decoded.data.multimodbus_EP6_slaveID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP6_fnctID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP6_datasize = bytes[index2];\n                            index2 = index2 + 1;\n                        }\n                        decoded.data.multimodbus_EP6_payload = \"\"\n                        if (bytes[index2] === undefined) return decoded;\n                        for (var j = 0; j < decoded.data.multimodbus_EP6_datasize; j++) {\n                            temp_hex_str = bytes[index2 + j].toString(16).toUpperCase();\n                            if (temp_hex_str.length == 1) {\n                                temp_hex_str = \"0\" + temp_hex_str;\n                            }\n                            decoded.data.multimodbus_EP6_payload += temp_hex_str;\n                        }\n                        index2 = index2 + decoded.data.multimodbus_EP6_datasize;\n                    }\n                    if (decoded.data.multimodbus_EP7 === true) {\n                        if (without_header === 0) {\n                            decoded.data.multimodbus_EP7_slaveID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP7_fnctID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP7_datasize = bytes[index2];\n                            index2 = index2 + 1;\n                        }\n                        decoded.data.multimodbus_EP7_payload = \"\"\n                        if (bytes[index2] === undefined) return decoded;\n                        for (var j = 0; j < decoded.data.multimodbus_EP7_datasize; j++) {\n                            temp_hex_str = bytes[index2 + j].toString(16).toUpperCase();\n                            if (temp_hex_str.length == 1) {\n                                temp_hex_str = \"0\" + temp_hex_str;\n                            }\n                            decoded.data.multimodbus_EP7_payload += temp_hex_str;\n                        }\n                        index2 = index2 + decoded.data.multimodbus_EP7_datasize;\n                    }\n                    if (decoded.data.multimodbus_EP8 === true) {\n                        if (without_header === 0) {\n                            decoded.data.multimodbus_EP8_slaveID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP8_fnctID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP8_datasize = bytes[index2];\n                            index2 = index2 + 1;\n                        }\n                        decoded.data.multimodbus_EP8_payload = \"\"\n                        if (bytes[index2] === undefined) return decoded;\n                        for (var j = 0; j < decoded.data.multimodbus_EP8_datasize; j++) {\n                            temp_hex_str = bytes[index2 + j].toString(16).toUpperCase();\n                            if (temp_hex_str.length == 1) {\n                                temp_hex_str = \"0\" + temp_hex_str;\n                            }\n                            decoded.data.multimodbus_EP8_payload += temp_hex_str;\n                        }\n                        index2 = index2 + decoded.data.multimodbus_EP8_datasize;\n                    }\n                    if (decoded.data.multimodbus_EP9 === true) {\n                        if (without_header === 0) {\n                            decoded.data.multimodbus_EP6_slaveID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP6_fnctID = bytes[index2];\n                            index2 = index2 + 1;\n                            decoded.data.multimodbus_EP6_datasize = bytes[index2];\n                            index2 = index2 + 1;\n                        }\n                        decoded.data.multimodbus_EP6_payload = \"\"\n                        if (bytes[index2] === undefined) return decoded;\n                        for (var j = 0; j < decoded.data.multimodbus_EP6_datasize; j++) {\n                            temp_hex_str = bytes[index2 + j].toString(16).toUpperCase();\n                            if (temp_hex_str.length == 1) {\n                                temp_hex_str = \"0\" + temp_hex_str;\n                            }\n                            decoded.data.multimodbus_EP6_payload += temp_hex_str;\n                        }\n                        index2 = index2 + decoded.data.multimodbus_EP6_datasize;\n                    }\n\n                }\n\n                //simple metering\n                if ((clusterdID === 0x0052) && (attributID === 0x0000)) {\n                    decoded.data.active_energy_Wh = UintToInt(bytes[index + 1] * 256 * 256 + bytes[index + 2] * 256 + bytes[index + 3], 3);\n                    decoded.data.reactive_energy_Varh = UintToInt(bytes[index + 4] * 256 * 256 + bytes[index + 5] * 256 + bytes[index + 6], 3);\n                    decoded.data.nb_samples = (bytes[index + 7] * 256 + bytes[index + 8]);\n                    decoded.data.active_power_W = UintToInt(bytes[index + 9] * 256 + bytes[index + 10], 2);\n                    decoded.data.reactive_power_VAR = UintToInt(bytes[index + 11] * 256 + bytes[index + 12], 2);\n                }\n                // TIC: \"TELE INFORMATION CLIENT\"\n                if ((clusterdID === 0x0053) || (clusterdID === 0x0054) || (clusterdID === 0x0055) || (clusterdID === 0x0056) || (clusterdID === 0x0057)) {\n\n                    decoded.data = TIC_Decode(clusterdID, attributID, bytes.slice(index + 1));\n                }\n                // lorawan message type\n                if ((clusterdID === 0x8004) && (attributID === 0x0000)) {\n                    if (bytes[index] === 1)\n                        decoded.data.message_type = \"confirmed\";\n                    if (bytes[index] === 0)\n                        decoded.data.message_type = \"unconfirmed\";\n                }\n\n                // lorawan retry\n                if ((clusterdID === 0x8004) && (attributID === 0x0001)) {\n                    decoded.data.nb_retry = bytes[index];\n                }\n\n                // lorawan reassociation\n                if ((clusterdID === 0x8004) && (attributID === 0x0002)) {\n                    decoded.data.period_in_minutes = bytes[index + 1] * 256 + bytes[index + 2];\n                    decoded.data.nb_err_frames = bytes[index + 3] * 256 + bytes[index + 4];\n                }\n                let index2\n                // configuration node power desc\n                if ((clusterdID === 0x0050) && (attributID === 0x0006)) {\n                    index2 = index + 3;\n                    if ((bytes[index + 2] & 0x01) === 0x01) { decoded.data.main_or_external_voltage = (bytes[index2] * 256 + bytes[index2 + 1]) / 1000; index2 = index2 + 2; }\n                    if ((bytes[index + 2] & 0x02) === 0x02) { decoded.data.rechargeable_battery_voltage = (bytes[index2] * 256 + bytes[index2 + 1]) / 1000; index2 = index2 + 2; }\n                    if ((bytes[index + 2] & 0x04) === 0x04) { decoded.data.disposable_battery_voltage = (bytes[index2] * 256 + bytes[index2 + 1]) / 1000; index2 = index2 + 2; }\n                    if ((bytes[index + 2] & 0x08) === 0x08) { decoded.data.solar_harvesting_voltage = (bytes[index2] * 256 + bytes[index2 + 1]) / 1000; index2 = index2 + 2; }\n                    if ((bytes[index + 2] & 0x10) === 0x10) { decoded.data.tic_harvesting_voltage = (bytes[index2] * 256 + bytes[index2 + 1]) / 1000; index2 = index2 + 2; }\n                }\n                //energy and power metering\n                if ((clusterdID === 0x800a) && (attributID === 0x0000)) {\n                    index2 = index;\n                    decoded.data.sum_positive_active_energy_Wh = UintToInt(bytes[index2 + 1] * 256 * 256 * 256 + bytes[index2 + 2] * 256 * 256 + bytes[index2 + 3] * 256 + bytes[index2 + 4], 4);\n                    index2 = index2 + 4;\n                    decoded.data.sum_negative_active_energy_Wh = UintToInt(bytes[index2 + 1] * 256 * 256 * 256 + bytes[index2 + 2] * 256 * 256 + bytes[index2 + 3] * 256 + bytes[index2 + 4], 4);\n                    index2 = index2 + 4;\n                    decoded.data.sum_positive_reactive_energy_Wh = UintToInt(bytes[index2 + 1] * 256 * 256 * 256 + bytes[index2 + 2] * 256 * 256 + bytes[index2 + 3] * 256 + bytes[index2 + 4], 4);\n                    index2 = index2 + 4;\n                    decoded.data.sum_negative_reactive_energy_Wh = UintToInt(bytes[index2 + 1] * 256 * 256 * 256 + bytes[index2 + 2] * 256 * 256 + bytes[index2 + 3] * 256 + bytes[index2 + 4], 4);\n                    index2 = index2 + 4;\n                    decoded.data.positive_active_power_W = UintToInt(bytes[index2 + 1] * 256 * 256 * 256 + bytes[index2 + 2] * 256 * 256 + bytes[index2 + 3] * 256 + bytes[index2 + 4], 4);\n                    index2 = index2 + 4;\n                    decoded.data.negative_active_power_W = UintToInt(bytes[index2 + 1] * 256 * 256 * 256 + bytes[index2 + 2] * 256 * 256 + bytes[index2 + 3] * 256 + bytes[index2 + 4], 4);\n                    index2 = index2 + 4;\n                    decoded.data.positive_reactive_power_W = UintToInt(bytes[index2 + 1] * 256 * 256 * 256 + bytes[index2 + 2] * 256 * 256 + bytes[index2 + 3] * 256 + bytes[index2 + 4], 4);\n                    index2 = index2 + 4;\n                    decoded.data.negative_reactive_power_W = UintToInt(bytes[index2 + 1] * 256 * 256 * 256 + bytes[index2 + 2] * 256 * 256 + bytes[index2 + 3] * 256 + bytes[index2 + 4], 4);\n                }\n                //energy and power metering\n                if ((clusterdID === 0x800b) && (attributID === 0x0000)) {\n                    index2 = index;\n                    decoded.data.Vrms = UintToInt(bytes[index2 + 1] * 256 + bytes[index2 + 2], 2) / 10;\n                    index2 = index2 + 2;\n                    decoded.data.Irms = UintToInt(bytes[index2 + 1] * 256 + bytes[index2 + 2], 2) / 10;\n                    index2 = index2 + 2;\n                    decoded.data.phase_angle = UintToInt(bytes[index2 + 1] * 256 + bytes[index2 + 2], 2);\n                }\n                //concentration\n                if ((clusterdID === 0x800c) && (attributID === 0x0000)) {\n                    decoded.data.Concentration = (bytes[index] * 256 + bytes[index + 1]);\n                }\n                //illuminance\n                if ((clusterdID === 0x0400) && (attributID === 0x0000)) {\n                    decoded.data.Illuminance = (bytes[index] * 256 + bytes[index + 1]);\n                }\n                //Pressure\n                if ((clusterdID === 0x0403) && (attributID === 0x0000)) {\n                    decoded.data.Pressure = (UintToInt(bytes[index] * 256 + bytes[index + 1], 2));\n                }\n                //Occupancy\n                if ((clusterdID === 0x0406) && (attributID === 0x0000)) {\n                    decoded.data.Occupancy = !(!bytes[index]);\n                }\n                // power quality by WattSense\n                if ((clusterdID === 0x8052) && (attributID === 0x0000)) {\n                    index2 = index;\n                    decoded.data.frequency =\n                        (UintToInt(\n                            bytes[index2 + 1] * 256 + bytes[index2 + 2],\n                            2\n                        ) +\n                            22232) /\n                        1000;\n                    index2 = index2 + 2;\n                    decoded.data.frequency_min =\n                        (UintToInt(\n                            bytes[index2 + 1] * 256 + bytes[index2 + 2],\n                            2\n                        ) +\n                            22232) /\n                        1000;\n                    index2 = index2 + 2;\n                    decoded.data.frequency_max =\n                        (UintToInt(\n                            bytes[index2 + 1] * 256 + bytes[index2 + 2],\n                            2\n                        ) +\n                            22232) /\n                        1000;\n                    index2 = index2 + 2;\n                    decoded.data.Vrms =\n                        UintToInt(\n                            bytes[index2 + 1] * 256 + bytes[index2 + 2],\n                            2\n                        ) / 10;\n                    index2 = index2 + 2;\n                    decoded.data.Vrms_min =\n                        UintToInt(\n                            bytes[index2 + 1] * 256 + bytes[index2 + 2],\n                            2\n                        ) / 10;\n                    index2 = index2 + 2;\n                    decoded.data.Vrms_max =\n                        UintToInt(\n                            bytes[index2 + 1] * 256 + bytes[index2 + 2],\n                            2\n                        ) / 10;\n                    index2 = index2 + 2;\n                    decoded.data.Vpeak =\n                        UintToInt(\n                            bytes[index2 + 1] * 256 + bytes[index2 + 2],\n                            2\n                        ) / 10;\n                    index2 = index2 + 2;\n                    decoded.data.Vpeak_min =\n                        UintToInt(\n                            bytes[index2 + 1] * 256 + bytes[index2 + 2],\n                            2\n                        ) / 10;\n                    index2 = index2 + 2;\n                    decoded.data.Vpeak_max =\n                        UintToInt(\n                            bytes[index2 + 1] * 256 + bytes[index2 + 2],\n                            2\n                        ) / 10;\n                    index2 = index2 + 2;\n                    decoded.data.over_voltage = UintToInt(\n                        bytes[index2 + 1] * 256 + bytes[index2 + 2],\n                        2\n                    );\n                    index2 = index2 + 2;\n                    decoded.data.sag_voltage = UintToInt(\n                        bytes[index2 + 1] * 256 + bytes[index2 + 2],\n                        2\n                    );\n                }\n\n                //XYZ Acceleration : Last on XYZ\n                if ((clusterdID === 0x800f)) {\n                    let i = index + 1;\n                    let o = {}\n                    if (attributID === 0x0000) {\n                        o = decoded.data.Last = {};\n                        o.NbTriggedAcq = BytesToInt64(bytes, i, \"U32\"); i += 4;\n                        o.Mean_X_G = BytesToInt64(bytes, i, \"U16\") / 100.0; i += 2;\n                        o.Max_X_G = BytesToInt64(bytes, i, \"U16\") / 100.0; i += 2;\n                        o.Dt_X_ms = BytesToInt64(bytes, i, \"U16\"); i += 2;\n                        o.Mean_Y_G = BytesToInt64(bytes, i, \"U16\") / 100.0; i += 2;\n                        o.Max_Y_G = BytesToInt64(bytes, i, \"U16\") / 100.0; i += 2;\n                        o.Dt_Y_ms = BytesToInt64(bytes, i, \"U16\"); i += 2;\n                        o.Mean_Z_G = BytesToInt64(bytes, i, \"U16\") / 100.0; i += 2;\n                        o.Max_Z_G = BytesToInt64(bytes, i, \"U16\") / 100.0; i += 2;\n                        o.Dt_Z_ms = BytesToInt64(bytes, i, \"U16\");\n                    } else if (attributID === 0x0001 || (attributID === 0x0002) || (attributID === 0x0003)) {\n                        let ext = (attributID === 0x0001 ? \"Stats_X\" : (attributID === 0x0002 ? \"Stats_Y\" : \"Stats_Z\"));\n                        o = decoded.data[ext] = {};\n                        o.NbAcq = BytesToInt64(bytes, i, \"U16\"); i += 2;\n                        o.MinMean_G = BytesToInt64(bytes, i, \"U16\") / 100.0; i += 2;\n                        o.MinMax_G = BytesToInt64(bytes, i, \"U16\") / 100.0; i += 2;\n                        o.MinDt = BytesToInt64(bytes, i, \"U16\"); i += 2;\n                        o.MeanMean_G = BytesToInt64(bytes, i, \"U16\") / 100.0; i += 2;\n                        o.MeanMax_G = BytesToInt64(bytes, i, \"U16\") / 100.0; i += 2;\n                        o.MeanDt = BytesToInt64(bytes, i, \"U16\"); i += 2;\n                        o.MaxMean_G = BytesToInt64(bytes, i, \"U16\") / 100.0; i += 2;\n                        o.MaxMax_G = BytesToInt64(bytes, i, \"U16\") / 100.0; i += 2;\n                        o.MaxDt = BytesToInt64(bytes, i, \"U16\"); i += 2;\n                    } else if (attributID === 0x8000) {\n                        o = decoded.data.Params = {};\n                        o.WaitFreq_Hz = BytesToInt64(bytes, i, \"U16\") / 10.0; i += 2;\n                        o.AcqFreq_Hz = BytesToInt64(bytes, i, \"U16\") / 10.0; i += 2;\n                        let delay = BytesToInt64(bytes, i, \"U16\"); i += 2;\n                        if (delay & 0x8000) delay = (delay & (~0x8000)) * 60;\n                        o.NewWaitDelay_s = (delay & 0x8000 ? delay = (delay & (~0x8000)) * 60 : delay);\n                        o.MaxAcqDuration_ms = BytesToInt64(bytes, i, \"U16\"); i += 2;\n                        o.Threshold_X_G = BytesToInt64(bytes, i, \"U16\") / 100.0; i += 2;\n                        o.Threshold_Y_G = BytesToInt64(bytes, i, \"U16\") / 100.0; i += 2;\n                        o.Threshold_Z_G = BytesToInt64(bytes, i, \"U16\") / 100.0; i += 2;\n                        o.OverThrsh_Dt_ms = BytesToInt64(bytes, i, \"U16\"); i += 2;\n                        o.UnderThrsh_Dt_ms = BytesToInt64(bytes, i, \"U16\"); i += 2;\n                        o.Range_G = BytesToInt64(bytes, i, \"U16\") / 100; i += 2;\n                        o.FilterSmoothCoef = BytesToInt64(bytes, i, \"U8\"); i += 1;\n                        o.FilterGainCoef = BytesToInt64(bytes, i, \"U8\"); i += 1;\n                        o = decoded.data.Params.WorkingModes = {};\n                        o.SignalEachAcq = (bytes[i] & 0x80 ? \"true\" : \"false\");\n                        o.RstAftStdRpt_X = (bytes[i] & 0x01 ? \"true\" : \"false\");\n                        o.RstAftStdRpt_Y = (bytes[i] & 0x02 ? \"true\" : \"false\");\n                        o.RstAftStdRpt_7 = (bytes[i] & 0x04 ? \"true\" : \"false\");\n                    }\n                }\n\n            }\n\n            //decode configuration response\n            if (cmdID === 0x07) {\n                //AttributID\n                attributID = bytes[6] * 256 + bytes[7]; decoded.zclheader.attributID = decimalToHex(attributID, 4);\n                //status\n                decoded.zclheader.status = bytes[4];\n                //batch\n                decoded.zclheader.batch = bytes[5];\n            }\n\n\n            //decode read configuration response\n            if (cmdID === 0x09) {\n                //AttributID\n                attributID = bytes[6] * 256 + bytes[7]; decoded.zclheader.attributID = decimalToHex(attributID, 4);\n                //status\n                decoded.zclheader.status = bytes[4];\n                //batch\n                decoded.zclheader.batch = bytes[5];\n\n                //AttributType\n                decoded.zclheader.attribut_type = bytes[8];\n                //min\n                decoded.zclheader.min = {}\n                if ((bytes[9] & 0x80) === 0x80) { decoded.zclheader.min.value = (bytes[9] - 0x80) * 256 + bytes[10]; decoded.zclheader.min.unity = \"minutes\"; } else { decoded.zclheader.min.value = bytes[9] * 256 + bytes[10]; decoded.zclheader.min.unity = \"seconds\"; }\n                //max\n                decoded.zclheader.max = {}\n                if ((bytes[11] & 0x80) === 0x80) { decoded.zclheader.max.value = (bytes[11] - 0x80) * 256 + bytes[12]; decoded.zclheader.max.unity = \"minutes\"; } else { decoded.zclheader.max.value = bytes[9] * 256 + bytes[10]; decoded.zclheader.max.unity = \"seconds\"; }\n                decoded.lora.payload = \"\";\n\n            }\n\n        }\n        else {\n            decoded.batch = {};\n            decoded.batch.report = \"batch\";\n        }\n    }\n    return decoded;\n}\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 200,
        "wires": [
            [
                "d7d0309cf06221d3"
            ]
        ],
        "icon": "font-awesome/fa-sun-o",
        "info": "### purpose \r\n\r\nThis node is used to decode tram from TIC sensir. \r\nThis is base ont the watteaco code hosted [there](https://support.nke-watteco.com/downloads/)\r\n\r\n\r\n## Input \r\nThe input must be the tram from the Tic sensor in hexa as a string.\r\nExample : \r\n```\r\nmsg.payload = \"110A005700004122680102030C28293706042036018312021709150A3B300D28D6B320005A320000300A\"\r\nmsg.port = 125 (optionnal only 125 work)\r\n```\r\n\r\n## Output\r\nThe output is the tram decoded  :\r\n\r\nExample : \r\n\r\n```\r\nmsg.payload = \r\n{\r\n  lora: {\r\n    port: 125,\r\n    payload: '110A005700004122680102030C28293706042036018312021709150A3B300D28D6B320005A320000300A',\r\n    date: '2023-05-30T07:17:06.623Z'\r\n  },\r\n  zclheader: {\r\n    report: 'standard',\r\n    endpoint: 0,\r\n    cmdID: '0x0A',\r\n    clusterdID: '0x0057',\r\n    attributID: '0x0000'\r\n  },\r\n  data: [\r\n    _TICFrameType: 'PMEPMI',\r\n    _Descriptor: {\r\n      Bytes: '680102030C282937',\r\n      Indexes: [\r\n         1,  2,  3, 12,\r\n        40, 41, 55\r\n      ]\r\n    },\r\n    ADS: '042036018312',\r\n    MESURES1: 'BT 4 SUP36',\r\n    DATE: '23/09/21 10:59:48',\r\n    PTCOUR1: 'HPE',\r\n    DebP: '17/08/2021 04:00:00',\r\n    EAP_s: 23090,\r\n    PS: { Value: 48, Label: 'kVA' }\r\n  ]\r\n}\r\n```"
    },
    {
        "id": "3abb7945e920ee57",
        "type": "inject",
        "z": "88c0a23c3a224791",
        "g": "df3290af4eccd44c",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "110A005700004122680102030C28293706042036018312021709150A3B300D28D6B320005A320000300A",
        "payloadType": "str",
        "x": 330,
        "y": 200,
        "wires": [
            [
                "642c9077cfcdc2fa"
            ]
        ]
    },
    {
        "id": "519acb1d.96e444",
        "type": "function",
        "z": "88c0a23c3a224791",
        "g": "65277b58fcc9b401",
        "name": "add in fifo",
        "func": "// new\nnode.send({payload : {order: \"set\",param: msg}})\n// node.send({payload : {order: \"set\",param: {payload : {order : \"askflow\"}}}})\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 460,
        "wires": [
            [
                "7475d947.971d78"
            ]
        ]
    },
    {
        "id": "7475d947.971d78",
        "type": "function",
        "z": "88c0a23c3a224791",
        "g": "65277b58fcc9b401",
        "name": "FIFO",
        "func": "// add at the end : Array.push() \n// remove from the top : Array.shift()\n\nvar fifo = context.get('FIFO') || []\nnode.status(fifo.length)\nif(msg.hasOwnProperty('payload') && msg.payload.hasOwnProperty('order')){\n    switch((msg.payload.order).toLowerCase()){\n        case 'clear' : \n            context.set('FIFO',[])\n        break\n        \n        case 'get':\n            if(fifo.length > 0){\n                let output =  fifo.shift()\n                context.set('FIFO',fifo)\n                // node.status(fifo.length)\n                return output\n            }\n        break\n        \n        case 'set':\n            if(msg.payload.param){\n                if(fifo.length === 0){node.status(\"start\")}\n                fifo.push(msg.payload.param)\n                context.set('FIFO',fifo)\n                // node.status(fifo.length)\n            }\n        break\n        \n        case 'list':\n            return { payload : fifo}\n        break\n        \n        default:\n            node.error(msg.paylod.order+\" is not a known order\")\n    }\n}\n\n\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "// Code added here will be run once\n// whenever the node is started.\ncontext.set('FIFO',[])",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 460,
        "wires": [
            [
                "2fe2b6b4d2dcd851"
            ]
        ],
        "icon": "node-red/db.svg",
        "info": "### Input\n```JSON\n    msg.payload = {\n        order : get / set / list / clear,\n        param : {} \n    }\n```\n\n## order\n**set**\n\nThis order is used to add `msg.payload.param` to the end of the Queue. If `msg.payload.param` is empty it would do nothing.\n\n**get**\n\nThis order is used to get the first item of the Queue. If Queue is empty it would do nothing. **msg will be exactly the first element**\n\n**list**\n\nThis order is used to get all element in the Queue. \n\n**clear**\n\nThis order is used to empty the Queue. "
    },
    {
        "id": "e4922ed8.1e2e5",
        "type": "function",
        "z": "88c0a23c3a224791",
        "g": "65277b58fcc9b401",
        "name": "start",
        "func": "try{\n    if(msg.status.text === \"start\"){\n        msg.payload ={}\n        msg.payload.order = \"get\"\n        msg.topic = \"NDRS\"\n        return msg; \n    }\n}\ncatch(error){\n    node.warn(error)\n}\n// return msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 420,
        "wires": [
            [
                "7475d947.971d78"
            ]
        ]
    },
    {
        "id": "1f6a7b77a5a149f9",
        "type": "status",
        "z": "88c0a23c3a224791",
        "g": "65277b58fcc9b401",
        "name": "",
        "scope": [
            "7475d947.971d78"
        ],
        "x": 160,
        "y": 420,
        "wires": [
            [
                "1973604a.b7afd"
            ]
        ]
    },
    {
        "id": "1973604a.b7afd",
        "type": "rbe",
        "z": "88c0a23c3a224791",
        "g": "65277b58fcc9b401",
        "name": "",
        "func": "rbe",
        "gap": "",
        "start": "",
        "inout": "out",
        "septopics": true,
        "property": "status.text",
        "topi": "topic",
        "x": 285,
        "y": 420,
        "wires": [
            [
                "e4922ed8.1e2e5"
            ]
        ],
        "l": false
    },
    {
        "id": "257677f7.022318",
        "type": "function",
        "z": "88c0a23c3a224791",
        "g": "65277b58fcc9b401",
        "name": "get next",
        "func": "msg.payload = {}\nmsg.payload.order = \"get\"\nreturn msg; \n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 380,
        "wires": [
            [
                "7475d947.971d78"
            ]
        ]
    },
    {
        "id": "b1ccc47612487ab2",
        "type": "link in",
        "z": "88c0a23c3a224791",
        "g": "65277b58fcc9b401",
        "name": "get next in",
        "links": [
            "16ae32af6b121e2b"
        ],
        "x": 285,
        "y": 380,
        "wires": [
            [
                "257677f7.022318"
            ]
        ]
    },
    {
        "id": "16ae32af6b121e2b",
        "type": "link out",
        "z": "88c0a23c3a224791",
        "g": "65277b58fcc9b401",
        "name": "to get next",
        "mode": "link",
        "links": [
            "b1ccc47612487ab2"
        ],
        "x": 1095,
        "y": 460,
        "wires": []
    },
    {
        "id": "37b2f2b5ee307f39",
        "type": "function",
        "z": "88c0a23c3a224791",
        "name": "To Modbus",
        "func": "var register_size = 4\n\nvar date = msg.payload.data_absolute_timestamp.toString(16).toUpperCase()\nvar value = msg.payload.data.value.toString(16).toUpperCase()\nvar date_send = []\nvar value_send=[]\nvar index = 0\nwhile (date_send.length <4 ){\n    if (date.length - (index + 4) >0){\n        date_send.push(parseInt(date.substring(date.length - (index + 4), date.length -index),16))\n    }\n    else if (date.length - (index) > 0){\n        date_send.push(parseInt(date.substring(0, date.length - index),16))\n    }\n    else{\n        date_send.push(0)\n    }\n\n    if (value.length - (index + 4) > 0) {\n        value_send.push(parseInt(value.substring(value.length - (index + 4), value.length - index),16))\n    }\n    else if (value.length - (index) > 0) {\n        value_send.push(parseInt(value.substring(0, value.length - index),16))\n    }\n    else {\n        value_send.push(0)\n    }\n    index = index+register_size\n    if(index >16 )break\n}\n\nnode.send({ payload: { value: date_send, 'fc': 16, 'unitid': 1, 'address': 0, 'quantity': 4 }})\n\nnode.send({ payload: { value: value_send, 'fc': 16, 'unitid': 2, 'address': 4, 'quantity': 4 } })\n\n// node.send({payload : { value: msg.payload.data.value, 'fc': 6, 'unitid': 1, 'address': 1, 'quantity': 1 },date:date_send,value : value_send} )\n\n// node.send({ payload: { value: new Date(msg.payload.data_relative_timestamp).getTime(), 'fc': 6, 'unitid': 1, 'address': 1, 'quantity': 1 } })\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1010,
        "y": 1120,
        "wires": [
            []
        ]
    },
    {
        "id": "ef8c72ed2afadb50",
        "type": "link in",
        "z": "88c0a23c3a224791",
        "g": "df3290af4eccd44c",
        "name": "test in ",
        "links": [
            "adaa94b8d6724b18"
        ],
        "x": 375,
        "y": 100,
        "wires": [
            [
                "9e9fdffdcf93cb78"
            ]
        ]
    },
    {
        "id": "2080b13d92474239",
        "type": "link in",
        "z": "88c0a23c3a224791",
        "g": "65277b58fcc9b401",
        "name": "V2 input Watteco",
        "links": [
            "bf764e78fe005200"
        ],
        "x": 285,
        "y": 460,
        "wires": [
            [
                "519acb1d.96e444"
            ]
        ]
    },
    {
        "id": "bf764e78fe005200",
        "type": "link out",
        "z": "88c0a23c3a224791",
        "g": "df3290af4eccd44c",
        "name": "To V2 Watteco",
        "mode": "link",
        "links": [
            "2080b13d92474239"
        ],
        "x": 905,
        "y": 140,
        "wires": []
    },
    {
        "id": "d7d0309cf06221d3",
        "type": "function",
        "z": "88c0a23c3a224791",
        "g": "df3290af4eccd44c",
        "name": "Tic to modbus",
        "func": "var index = 0\nvar register_start = 0\nconst register_size = 4\n\n// msg.payload.data.EAP_s // int\n// msg.payload.data.DATE // 23/09/21 10:59:48\n// msg.payload.data.PTCOUR1  // HPE\nif (msg.payload.hasOwnProperty(\"data\"))\n    if (msg.payload.data.hasOwnProperty(\"EAP_s\") && msg.payload.data.hasOwnProperty(\"DATE\") && msg.payload.data.hasOwnProperty(\"PTCOUR1\")){\n        msg.payload.data.EAP_s = msg.payload.data.EAP_s.toString(16).toUpperCase()\n        msg.payload.data.DATE = date_no_iso_to_timestamp(msg.payload.data.DATE) // to timestamp\n        msg.payload.data.DATE = msg.payload.data.DATE.toString(16).toUpperCase() // hex string\n        msg.payload.data.PTCOUR1 = msg.payload.data.PTCOUR1.split('') // to array\n        msg.payload.data.PTCOUR1 = msg.payload.data.PTCOUR1.map(x => x.charCodeAt(0));\n\n        let time_send = []\n        let date_send = []\n        let ptcour_send = msg.payload.data.PTCOUR1\n        while (date_send.length < 4) {\n            if (msg.payload.data.EAP_s.length - (index + 4) > 0) {\n                date_send.push(parseInt(msg.payload.data.EAP_s.substring(msg.payload.data.EAP_s.length - (index + 4), msg.payload.data.EAP_s.length - index), 16))\n            }\n            else if (msg.payload.data.EAP_s.length - (index) > 0) {\n                date_send.push(parseInt(msg.payload.data.EAP_s.substring(0, msg.payload.data.EAP_s.length - index), 16))\n            }\n            else {\n                date_send.push(0)\n            }\n\n            if (msg.payload.data.DATE.length - (index + 4) > 0) {\n                time_send.push(parseInt(msg.payload.data.DATE.substring(msg.payload.data.DATE.length - (index + 4), msg.payload.data.DATE.length - index), 16))\n            }\n            else if (msg.payload.data.DATE.length - (index) > 0) {\n                time_send.push(parseInt(msg.payload.data.DATE.substring(0, msg.payload.data.DATE.length - index), 16))\n            }\n            else {\n                time_send.push(0)\n            }\n            index = index + register_size\n        }\n        node.send({ payload: { value: time_send, 'fc': 16, 'unitid': 1, 'address': 100, 'quantity': 4 } })\n        node.send({ payload: { value: date_send, 'fc': 16, 'unitid': 1, 'address': 104, 'quantity': 4 } })\n        node.send({ payload: { value: ptcour_send, 'fc': 16, 'unitid': 1, 'address': 108, 'quantity': 3 } })\n\n\n\n\n        // return msg\n    }\n    else{\n        node.wanr(\"Wrong input in \"+node.name)\n    }\nelse {\n    node.wanr(\"Wrong input in \" + node.name)\n}\n// var date = msg.payload.data_absolute_timestamp.toString(16).toUpperCase()\n// var value = msg.payload.data.value.toString(16).toUpperCase()\n// var date_send = []\n// var value_send = []\n// var index = 0\n// while (date_send.length < 4) {\n//     if (date.length - (index + 4) > 0) {\n//         date_send.push(parseInt(date.substring(date.length - (index + 4), date.length - index), 16))\n//     }\n//     else if (date.length - (index) > 0) {\n//         date_send.push(parseInt(date.substring(0, date.length - index), 16))\n//     }\n//     else {\n//         date_send.push(0)\n//     }\n\n//     if (value.length - (index + 4) > 0) {\n//         value_send.push(parseInt(value.substring(value.length - (index + 4), value.length - index), 16))\n//     }\n//     else if (value.length - (index) > 0) {\n//         value_send.push(parseInt(value.substring(0, value.length - index), 16))\n//     }\n//     else {\n//         value_send.push(0)\n//     }\n//     index = index + register_size\n//     if (index > 16) break\n// }\n\n// node.send({ payload: { value: date_send, 'fc': 16, 'unitid': 1, 'address': 0, 'quantity': 4 } })\n\n// node.send({ payload: { value: value_send, 'fc': 16, 'unitid': 2, 'address': 4, 'quantity': 4 } })\n\n\nfunction date_no_iso_to_timestamp(dd) {\n    let day\n    let time\n    [day, time] = dd.split(' ')\n    day = day.split(\"/\")\n    day[day.length - 1] = \"20\" + day[day.length - 1]\n    day.reverse()\n    day = day.join(\"-\")\n    return new Date(day + \"T\" + time + \"Z\").getTime()\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 200,
        "wires": [
            [
                "bf764e78fe005200"
            ]
        ]
    },
    {
        "id": "491826d4ea340a46",
        "type": "function",
        "z": "88c0a23c3a224791",
        "g": "df3290af4eccd44c",
        "name": "Index1 to modbus",
        "func": "// msg.paylod est un array de json\nvar index = 0\nvar register_start = 0\nconst register_size = 4\n\nmsg.payload.dataset = msg.payload.dataset.filter(_d => _d.data.label_name === \"Index1\")\n\nmsg.payload.dataset.forEach((_d =>{\n    _d.data_absolute_timestamp = new Date(_d.data_absolute_timestamp).getTime()\n     }))\n\nwhile (msg.payload.dataset.length > 0){\n    // node.warn(\"\\t\" + msg.payload.dataset.length)\n    let date_send = []\n    let value_send = []\n    let indice = getMax(msg.payload.dataset,\"data_absolute_timestamp\")\n    let latest = msg.payload.dataset[indice]\n    latest.data_absolute_timestamp = latest.data_absolute_timestamp.toString(16).toUpperCase()\n    latest.data.value = latest.data.value.toString(16).toUpperCase()\n    while (date_send.length < register_size){\n        // node.warn(date_send.length)\n        if (latest.data_absolute_timestamp.length - (index + 4) > 0) {\n            date_send.push(parseInt(latest.data_absolute_timestamp.substring(latest.data_absolute_timestamp.length - (index + 4), latest.data_absolute_timestamp.length - index), 16))\n        }\n        else if (latest.data_absolute_timestamp.length - (index) > 0) {\n            date_send.push(parseInt(latest.data_absolute_timestamp.substring(0, latest.data_absolute_timestamp.length - index), 16))\n        }\n        else {\n            date_send.push(0)\n        } \n\n        if (latest.data.value.length - (index + 4) > 0) {\n            value_send.push(parseInt(latest.data.value.substring(latest.data.value.length - (index + 4), latest.data.value.length - index), 16))\n        }\n        else if (latest.data.value.length - (index) > 0) {\n            value_send.push(parseInt(latest.data.value.substring(0, latest.data.value.length - index), 16))\n        }\n        else {\n            value_send.push(0)\n        }\n        index = index + register_size\n    }\n    index = 0\n    node.send({ payload: { value: date_send, 'fc': 16, 'unitid': 1, 'address': register_start, 'quantity': register_size },topic:\"timestamp\" })\n    node.send({ payload: { value: value_send, 'fc': 16, 'unitid': 2, 'address': register_start + register_size, 'quantity': register_size }, topic: \"value\" })\n    \n    register_start = register_start + 2 * register_size\n    msg.payload.dataset.splice(indice,1)\n    if (register_start > (100-2*register_size)){\n        node.warn(\"Too far\")\n        break\n    }\n\n\n}\n\n// msg.payload.data_absolute_timestamp = new Date(msg.payload.data_absolute_timestamp)\n// return msg;\n\nfunction getMax(arr, prop) {\n    var max;\n    for (var i = 0; i < arr.length; i++) {\n        if (max == null || parseInt(arr[i][prop]) > parseInt(max[prop]))\n            // max = arr[i]; // get the element\n            max = i; // get the index\n    }\n    return max;\n}\n\n// \n\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 100,
        "wires": [
            [
                "bf764e78fe005200"
            ]
        ]
    },
    {
        "id": "2fe2b6b4d2dcd851",
        "type": "modbus-flex-write",
        "z": "88c0a23c3a224791",
        "g": "65277b58fcc9b401",
        "name": "",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "server": "1e1c575a819c6269",
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 950,
        "y": 460,
        "wires": [
            [
                "16ae32af6b121e2b"
            ],
            []
        ]
    },
    {
        "id": "59f85f1a37c76b2b",
        "type": "tcp in",
        "z": "bb145069bb135c47",
        "g": "dfc06c552b41984f",
        "name": "",
        "server": "server",
        "host": "",
        "port": "1025",
        "datamode": "stream",
        "datatype": "buffer",
        "newline": "",
        "topic": "",
        "trim": false,
        "base64": false,
        "tls": "",
        "x": 120,
        "y": 60,
        "wires": [
            [
                "d426500231149c27"
            ]
        ]
    },
    {
        "id": "d426500231149c27",
        "type": "json",
        "z": "bb145069bb135c47",
        "g": "dfc06c552b41984f",
        "name": "",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 350,
        "y": 60,
        "wires": [
            [
                "870490657bde3b97",
                "80b59f0f61cfd322"
            ]
        ],
        "info": "### msg.payload as \r\n\r\n"
    },
    {
        "id": "9c5852b5e4f85c15",
        "type": "file",
        "z": "bb145069bb135c47",
        "g": "dfc06c552b41984f",
        "name": "",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": true,
        "createDir": true,
        "overwriteFile": "true",
        "encoding": "none",
        "x": 840,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "870490657bde3b97",
        "type": "function",
        "z": "bb145069bb135c47",
        "g": "dfc06c552b41984f",
        "name": "save last income as txt",
        "func": "msg.filename = \"/home/admin/lorawan/\" + msg.payload.end_device_id+\".txt\"\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 620,
        "y": 120,
        "wires": [
            [
                "9c5852b5e4f85c15"
            ]
        ]
    },
    {
        "id": "f7cfa05cd25b46d5",
        "type": "link out",
        "z": "bb145069bb135c47",
        "g": "dfc06c552b41984f",
        "name": "Gateway_to_decode_output",
        "mode": "link",
        "links": [
            "a229b509d8298ee1"
        ],
        "x": 805,
        "y": 60,
        "wires": []
    },
    {
        "id": "80b59f0f61cfd322",
        "type": "function",
        "z": "bb145069bb135c47",
        "g": "dfc06c552b41984f",
        "name": "change payload to rxdata",
        "func": "msg.rx_data  = msg.payload\nmsg.payload = {}\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 60,
        "wires": [
            [
                "f7cfa05cd25b46d5"
            ]
        ]
    }
]